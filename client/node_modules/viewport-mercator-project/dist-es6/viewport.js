var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// View and Projection Matrix management

// gl-matrix is a large dependency for a small module.
// However since it is used by mapbox etc, it should already be present
// in most target application bundles.
import { mat4, vec4, vec2 } from 'gl-matrix';
import autobind from './autobind';
import assert from 'assert';

var IDENTITY = createMat4();

var ERR_ARGUMENT = 'Illegal argument to Viewport';

var Viewport = function () {
  /**
   * @classdesc
   * Manages coordinate system transformations for deck.gl.
   *
   * Note: The Viewport is immutable in the sense that it only has accessors.
   * A new viewport instance should be created if any parameters have changed.
   *
   * @class
   * @param {Object} opt - options
   * @param {Boolean} mercator=true - Whether to use mercator projection
   *
   * @param {Number} opt.width=1 - Width of "viewport" or window
   * @param {Number} opt.height=1 - Height of "viewport" or window
   * @param {Array} opt.center=[0, 0] - Center of viewport
   *   [longitude, latitude] or [x, y]
   * @param {Number} opt.scale=1 - Either use scale or zoom
   * @param {Number} opt.pitch=0 - Camera angle in degrees (0 is straight down)
   * @param {Number} opt.bearing=0 - Map rotation in degrees (0 means north is up)
   * @param {Number} opt.altitude= - Altitude of camera in screen units
   *
   * Web mercator projection short-hand parameters
   * @param {Number} opt.latitude - Center of viewport on map (alternative to opt.center)
   * @param {Number} opt.longitude - Center of viewport on map (alternative to opt.center)
   * @param {Number} opt.zoom - Scale = Math.pow(2,zoom) on map (alternative to opt.scale)
   */
  /* eslint-disable complexity */
  function Viewport() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$width = _ref.width,
        width = _ref$width === undefined ? 1 : _ref$width,
        _ref$height = _ref.height,
        height = _ref$height === undefined ? 1 : _ref$height,
        _ref$viewMatrix = _ref.viewMatrix,
        viewMatrix = _ref$viewMatrix === undefined ? IDENTITY : _ref$viewMatrix,
        _ref$projectionMatrix = _ref.projectionMatrix,
        projectionMatrix = _ref$projectionMatrix === undefined ? IDENTITY : _ref$projectionMatrix;

    _classCallCheck(this, Viewport);

    // Silently allow apps to send in 0,0
    this.width = width || 1;
    this.height = height || 1;
    this.scale = 1;

    this.viewMatrix = viewMatrix;
    this.projectionMatrix = projectionMatrix;

    // Note: As usual, matrix operations should be applied in "reverse" order
    // since vectors will be multiplied in from the right during transformation
    var vpm = createMat4();
    mat4.multiply(vpm, vpm, this.projectionMatrix);
    mat4.multiply(vpm, vpm, this.viewMatrix);
    this.viewProjectionMatrix = vpm;

    // Calculate matrices and scales needed for projection
    /**
     * Builds matrices that converts preprojected lngLats to screen pixels
     * and vice versa.
     * Note: Currently returns bottom-left coordinates!
     * Note: Starts with the GL projection matrix and adds steps to the
     *       scale and translate that matrix onto the window.
     * Note: WebGL controls clip space to screen projection with gl.viewport
     *       and does not need this step.
     */
    var m = createMat4();

    // matrix for conversion from location to screen coordinates
    mat4.scale(m, m, [this.width / 2, -this.height / 2, 1]);
    mat4.translate(m, m, [1, -1, 0]);

    // Scale with viewport window's width and height in pixels
    // mat4.scale(m, m, [this.width, this.height, 1]);
    // Convert to (0, 1)
    // mat4.translate(m, m, [0.5, 0.5, 0]);
    // mat4.scale(m, m, [0.5, 0.5, 1]);
    // Project to clip space (-1, 1)
    mat4.multiply(m, m, this.viewProjectionMatrix);

    // console.log(`vec ${[this.width / 2, this.height / 2, 1]}`);
    // console.log(`View ${this.viewMatrix}`);
    // console.log(`VPM ${vpm}`);
    // console.log(`Pixel ${m}`);

    var mInverse = mat4.invert(createMat4(), m);
    if (!mInverse) {
      throw new Error('Pixel project matrix not invertible');
    }

    this.pixelProjectionMatrix = m;
    this.pixelUnprojectionMatrix = mInverse;

    autobind(this);
  }
  /* eslint-enable complexity */

  // Two viewports are equal if width and height are identical, and if
  // their view and projection matrices are (approximately) equal.


  _createClass(Viewport, [{
    key: 'equals',
    value: function equals(viewport) {
      if (!(viewport instanceof Viewport)) {
        return false;
      }

      return viewport.width === this.width && viewport.height === this.height && mat4.equals(viewport.projectionMatrix, this.projectionMatrix) && mat4.equals(viewport.viewMatrix, this.viewMatrix);
    }

    /**
     * Projects xyz (possibly latitude and longitude) to pixel coordinates in window
     * using viewport projection parameters
     * - [longitude, latitude] to [x, y]
     * - [longitude, latitude, Z] => [x, y, z]
     * Note: By default, returns top-left coordinates for canvas/SVG type render
     *
     * @param {Array} lngLatZ - [lng, lat] or [lng, lat, Z]
     * @param {Object} opts - options
     * @param {Object} opts.topLeft=true - Whether projected coords are top left
     * @return {Array} - [x, y] or [x, y, z] in top left coords
     */

  }, {
    key: 'project',
    value: function project(xyz) {
      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref2$topLeft = _ref2.topLeft,
          topLeft = _ref2$topLeft === undefined ? false : _ref2$topLeft;

      var _xyz = _slicedToArray(xyz, 3),
          x0 = _xyz[0],
          y0 = _xyz[1],
          _xyz$ = _xyz[2],
          z0 = _xyz$ === undefined ? 0 : _xyz$;

      assert(Number.isFinite(x0) && Number.isFinite(y0) && Number.isFinite(z0), ERR_ARGUMENT);

      var _projectFlat = this.projectFlat([x0, y0]),
          _projectFlat2 = _slicedToArray(_projectFlat, 2),
          X = _projectFlat2[0],
          Y = _projectFlat2[1];

      var v = this.transformVector(this.pixelProjectionMatrix, [X, Y, z0, 1]);

      var _v = _slicedToArray(v, 2),
          x = _v[0],
          y = _v[1];

      var y2 = topLeft ? this.height - y : y;
      return xyz.length === 2 ? [x, y2] : [x, y2, 0];
    }

    /**
     * Unproject pixel coordinates on screen onto world coordinates,
     * (possibly [lon, lat]) on map.
     * - [x, y] => [lng, lat]
     * - [x, y, z] => [lng, lat, Z]
     * @param {Array} xyz -
     * @return {Array} - [lng, lat, Z] or [X, Y, Z]
     */

  }, {
    key: 'unproject',
    value: function unproject(xyz) {
      var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref3$topLeft = _ref3.topLeft,
          topLeft = _ref3$topLeft === undefined ? false : _ref3$topLeft;

      var _xyz2 = _slicedToArray(xyz, 3),
          x = _xyz2[0],
          y = _xyz2[1],
          _xyz2$ = _xyz2[2],
          targetZ = _xyz2$ === undefined ? 0 : _xyz2$;

      var y2 = topLeft ? this.height - y : y;

      // since we don't know the correct projected z value for the point,
      // unproject two points to get a line and then find the point on that line with z=0
      var coord0 = this.transformVector(this.pixelUnprojectionMatrix, [x, y2, 0, 1]);
      var coord1 = this.transformVector(this.pixelUnprojectionMatrix, [x, y2, 1, 1]);

      var z0 = coord0[2];
      var z1 = coord1[2];

      var t = z0 === z1 ? 0 : (targetZ - z0) / (z1 - z0);
      var v = vec2.lerp([], coord0, coord1, t);

      // console.error(`unprojecting to non-linear ${v}<=${[x, y2, targetZ]}`);

      var vUnprojected = this.unprojectFlat(v);
      return xyz.length === 2 ? vUnprojected : [vUnprojected[0], vUnprojected[1], 0];
    }

    // TODO - replace with math.gl

  }, {
    key: 'transformVector',
    value: function transformVector(matrix, vector) {
      var result = vec4.transformMat4([0, 0, 0, 0], vector, matrix);
      var scale = 1 / result[3];
      vec4.multiply(result, result, [scale, scale, scale, scale]);
      return result;
    }

    // NON_LINEAR PROJECTION HOOKS
    // Used for web meractor projection

    /**
     * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.
     * Performs the nonlinear part of the web mercator projection.
     * Remaining projection is done with 4x4 matrices which also handles
     * perspective.
     * @param {Array} lngLat - [lng, lat] coordinates
     *   Specifies a point on the sphere to project onto the map.
     * @return {Array} [x,y] coordinates.
     */

  }, {
    key: 'projectFlat',
    value: function projectFlat(_ref4) {
      var _ref5 = _slicedToArray(_ref4, 2),
          x = _ref5[0],
          y = _ref5[1];

      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      return this._projectFlat.apply(this, arguments);
    }

    /**
     * Unproject world point [x,y] on map onto {lat, lon} on sphere
     * @param {object|Vector} xy - object with {x,y} members
     *  representing point on projected map plane
     * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.
     *   Has toArray method if you need a GeoJSON Array.
     *   Per cartographic tradition, lat and lon are specified as degrees.
     */

  }, {
    key: 'unprojectFlat',
    value: function unprojectFlat(xyz) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      return this._unprojectFlat.apply(this, arguments);
    }
  }, {
    key: 'getMatrices',
    value: function getMatrices() {
      var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref6$modelMatrix = _ref6.modelMatrix,
          modelMatrix = _ref6$modelMatrix === undefined ? null : _ref6$modelMatrix;

      var modelViewProjectionMatrix = this.viewProjectionMatrix;
      var pixelProjectionMatrix = this.pixelProjectionMatrix;
      var pixelUnprojectionMatrix = this.pixelUnprojectionMatrix;

      if (modelMatrix) {
        modelViewProjectionMatrix = mat4.multiply([], this.viewProjectionMatrix, modelMatrix);
        pixelProjectionMatrix = mat4.multiply([], this.pixelProjectionMatrix, modelMatrix);
        pixelUnprojectionMatrix = mat4.invert([], pixelProjectionMatrix);
      }

      var matrices = Object.assign({
        modelViewProjectionMatrix: modelViewProjectionMatrix,
        viewProjectionMatrix: this.viewProjectionMatrix,
        viewMatrix: this.viewMatrix,
        projectionMatrix: this.projectionMatrix,

        // project/unproject between pixels and world
        pixelProjectionMatrix: pixelProjectionMatrix,
        pixelUnprojectionMatrix: pixelUnprojectionMatrix,

        width: this.width,
        height: this.height,
        scale: this.scale
      },

      // Subclass can add additional params
      // TODO - Fragile: better to make base Viewport class aware of all params
      this._getParams());

      return matrices;
    }

    // INTERNAL METHODS

    // Can be subclassed to add additional fields to `getMatrices`

  }, {
    key: '_getParams',
    value: function _getParams() {
      return {};
    }
  }]);

  return Viewport;
}();

// Helper, avoids low-precision 32 bit matrices from gl-matrix mat4.create()


export default Viewport;
export function createMat4() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy92aWV3cG9ydC5qcyJdLCJuYW1lcyI6WyJtYXQ0IiwidmVjNCIsInZlYzIiLCJhdXRvYmluZCIsImFzc2VydCIsIklERU5USVRZIiwiY3JlYXRlTWF0NCIsIkVSUl9BUkdVTUVOVCIsIlZpZXdwb3J0Iiwid2lkdGgiLCJoZWlnaHQiLCJ2aWV3TWF0cml4IiwicHJvamVjdGlvbk1hdHJpeCIsInNjYWxlIiwidnBtIiwibXVsdGlwbHkiLCJ2aWV3UHJvamVjdGlvbk1hdHJpeCIsIm0iLCJ0cmFuc2xhdGUiLCJtSW52ZXJzZSIsImludmVydCIsIkVycm9yIiwicGl4ZWxQcm9qZWN0aW9uTWF0cml4IiwicGl4ZWxVbnByb2plY3Rpb25NYXRyaXgiLCJ2aWV3cG9ydCIsImVxdWFscyIsInh5eiIsInRvcExlZnQiLCJ4MCIsInkwIiwiejAiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsInByb2plY3RGbGF0IiwiWCIsIlkiLCJ2IiwidHJhbnNmb3JtVmVjdG9yIiwieCIsInkiLCJ5MiIsImxlbmd0aCIsInRhcmdldFoiLCJjb29yZDAiLCJjb29yZDEiLCJ6MSIsInQiLCJsZXJwIiwidlVucHJvamVjdGVkIiwidW5wcm9qZWN0RmxhdCIsIm1hdHJpeCIsInZlY3RvciIsInJlc3VsdCIsInRyYW5zZm9ybU1hdDQiLCJfcHJvamVjdEZsYXQiLCJhcmd1bWVudHMiLCJfdW5wcm9qZWN0RmxhdCIsIm1vZGVsTWF0cml4IiwibW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCIsIm1hdHJpY2VzIiwiT2JqZWN0IiwiYXNzaWduIiwiX2dldFBhcmFtcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUUEsSUFBUixFQUFjQyxJQUFkLEVBQW9CQyxJQUFwQixRQUErQixXQUEvQjtBQUNBLE9BQU9DLFFBQVAsTUFBcUIsWUFBckI7QUFDQSxPQUFPQyxNQUFQLE1BQW1CLFFBQW5COztBQUVBLElBQU1DLFdBQVdDLFlBQWpCOztBQUVBLElB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T0FBTyxTQUFTRixVQUFULEdBQXNCO0FBQzNCLFNBQU8sQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixFQUFtQixDQUFuQixFQUFzQixDQUF0QixFQUF5QixDQUF6QixFQUE0QixDQUE1QixFQUErQixDQUEvQixFQUFrQyxDQUFsQyxFQUFxQyxDQUFyQyxFQUF3QyxDQUF4QyxFQUEyQyxDQUEzQyxFQUE4QyxDQUE5QyxDQUFQO0FBQ0QiLCJmaWxlIjoidmlld3BvcnQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBWaWV3IGFuZCBQcm9qZWN0aW9uIE1hdHJpeCBtYW5hZ2VtZW50XG5cbi8vIGdsLW1hdHJpeCBpcyBhIGxhcmdlIGRlcGVuZGVuY3kgZm9yIGEgc21hbGwgbW9kdWxlLlxuLy8gSG93ZXZlciBzaW5jZSBpdCBpcyB1c2VkIGJ5IG1hcGJveCBldGMsIGl0IHNob3VsZCBhbHJlYWR5IGJlIHByZXNlbnRcbi8vIGluIG1vc3QgdGFyZ2V0IGFwcGxpY2F0aW9uIGJ1bmRsZXMuXG5pbXBvcnQge21hdDQsIHZlYzQsIHZlYzJ9IGZyb20gJ2dsLW1hdHJpeCc7XG5pbXBvcnQgYXV0b2JpbmQgZnJvbSAnLi9hdXRvYmluZCc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5cbmNvbnN0IElERU5USVRZID0gY3JlYXRlTWF0NCgpO1xuXG5jb25zdCBFUlJfQVJHVU1FTlQgPSAnSWxsZWdhbCBhcmd1bWVudCB0byBWaWV3cG9ydCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZpZXdwb3J0IHtcbiAgLyoqXG4gICAqIEBjbGFzc2Rlc2NcbiAgICogTWFuYWdlcyBjb29yZGluYXRlIHN5c3RlbSB0cmFuc2Zvcm1hdGlvbnMgZm9yIGRlY2suZ2wuXG4gICAqXG4gICAqIE5vdGU6IFRoZSBWaWV3cG9ydCBpcyBpbW11dGFibGUgaW4gdGhlIHNlbnNlIHRoYXQgaXQgb25seSBoYXMgYWNjZXNzb3JzLlxuICAgKiBBIG5ldyB2aWV3cG9ydCBpbnN0YW5jZSBzaG91bGQgYmUgY3JlYXRlZCBpZiBhbnkgcGFyYW1ldGVycyBoYXZlIGNoYW5nZWQuXG4gICAqXG4gICAqIEBjbGFzc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0IC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG1lcmNhdG9yPXRydWUgLSBXaGV0aGVyIHRvIHVzZSBtZXJjYXRvciBwcm9qZWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQud2lkdGg9MSAtIFdpZHRoIG9mIFwidmlld3BvcnRcIiBvciB3aW5kb3dcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC5oZWlnaHQ9MSAtIEhlaWdodCBvZiBcInZpZXdwb3J0XCIgb3Igd2luZG93XG4gICAqIEBwYXJhbSB7QXJyYXl9IG9wdC5jZW50ZXI9WzAsIDBdIC0gQ2VudGVyIG9mIHZpZXdwb3J0XG4gICAqICAgW2xvbmdpdHVkZSwgbGF0aXR1ZGVdIG9yIFt4LCB5XVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LnNjYWxlPTEgLSBFaXRoZXIgdXNlIHNjYWxlIG9yIHpvb21cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC5waXRjaD0wIC0gQ2FtZXJhIGFuZ2xlIGluIGRlZ3JlZXMgKDAgaXMgc3RyYWlnaHQgZG93bilcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC5iZWFyaW5nPTAgLSBNYXAgcm90YXRpb24gaW4gZGVncmVlcyAoMCBtZWFucyBub3J0aCBpcyB1cClcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC5hbHRpdHVkZT0gLSBBbHRpdHVkZSBvZiBjYW1lcmEgaW4gc2NyZWVuIHVuaXRzXG4gICAqXG4gICAqIFdlYiBtZXJjYXRvciBwcm9qZWN0aW9uIHNob3J0LWhhbmQgcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LmxhdGl0dWRlIC0gQ2VudGVyIG9mIHZpZXdwb3J0IG9uIG1hcCAoYWx0ZXJuYXRpdmUgdG8gb3B0LmNlbnRlcilcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC5sb25naXR1ZGUgLSBDZW50ZXIgb2Ygdmlld3BvcnQgb24gbWFwIChhbHRlcm5hdGl2ZSB0byBvcHQuY2VudGVyKVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0Lnpvb20gLSBTY2FsZSA9IE1hdGgucG93KDIsem9vbSkgb24gbWFwIChhbHRlcm5hdGl2ZSB0byBvcHQuc2NhbGUpXG4gICAqL1xuICAvKiBlc2xpbnQtZGlzYWJsZSBjb21wbGV4aXR5ICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICAvLyBXaW5kb3cgd2lkdGgvaGVpZ2h0IGluIHBpeGVscyAoZm9yIHBpeGVsIHByb2plY3Rpb24pXG4gICAgd2lkdGggPSAxLFxuICAgIGhlaWdodCA9IDEsXG4gICAgLy8gRGVzY1xuICAgIHZpZXdNYXRyaXggPSBJREVOVElUWSxcbiAgICBwcm9qZWN0aW9uTWF0cml4ID0gSURFTlRJVFlcbiAgfSA9IHt9KSB7XG4gICAgLy8gU2lsZW50bHkgYWxsb3cgYXBwcyB0byBzZW5kIGluIDAsMFxuICAgIHRoaXMud2lkdGggPSB3aWR0aCB8fCAxO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0IHx8IDE7XG4gICAgdGhpcy5zY2FsZSA9IDE7XG5cbiAgICB0aGlzLnZpZXdNYXRyaXggPSB2aWV3TWF0cml4O1xuICAgIHRoaXMucHJvamVjdGlvbk1hdHJpeCA9IHByb2plY3Rpb25NYXRyaXg7XG5cbiAgICAvLyBOb3RlOiBBcyB1c3VhbCwgbWF0cml4IG9wZXJhdGlvbnMgc2hvdWxkIGJlIGFwcGxpZWQgaW4gXCJyZXZlcnNlXCIgb3JkZXJcbiAgICAvLyBzaW5jZSB2ZWN0b3JzIHdpbGwgYmUgbXVsdGlwbGllZCBpbiBmcm9tIHRoZSByaWdodCBkdXJpbmcgdHJhbnNmb3JtYXRpb25cbiAgICBjb25zdCB2cG0gPSBjcmVhdGVNYXQ0KCk7XG4gICAgbWF0NC5tdWx0aXBseSh2cG0sIHZwbSwgdGhpcy5wcm9qZWN0aW9uTWF0cml4KTtcbiAgICBtYXQ0Lm11bHRpcGx5KHZwbSwgdnBtLCB0aGlzLnZpZXdNYXRyaXgpO1xuICAgIHRoaXMudmlld1Byb2plY3Rpb25NYXRyaXggPSB2cG07XG5cbiAgICAvLyBDYWxjdWxhdGUgbWF0cmljZXMgYW5kIHNjYWxlcyBuZWVkZWQgZm9yIHByb2plY3Rpb25cbiAgICAvKipcbiAgICAgKiBCdWlsZHMgbWF0cmljZXMgdGhhdCBjb252ZXJ0cyBwcmVwcm9qZWN0ZWQgbG5nTGF0cyB0byBzY3JlZW4gcGl4ZWxzXG4gICAgICogYW5kIHZpY2UgdmVyc2EuXG4gICAgICogTm90ZTogQ3VycmVudGx5IHJldHVybnMgYm90dG9tLWxlZnQgY29vcmRpbmF0ZXMhXG4gICAgICogTm90ZTogU3RhcnRzIHdpdGggdGhlIEdMIHByb2plY3Rpb24gbWF0cml4IGFuZCBhZGRzIHN0ZXBzIHRvIHRoZVxuICAgICAqICAgICAgIHNjYWxlIGFuZCB0cmFuc2xhdGUgdGhhdCBtYXRyaXggb250byB0aGUgd2luZG93LlxuICAgICAqIE5vdGU6IFdlYkdMIGNvbnRyb2xzIGNsaXAgc3BhY2UgdG8gc2NyZWVuIHByb2plY3Rpb24gd2l0aCBnbC52aWV3cG9ydFxuICAgICAqICAgICAgIGFuZCBkb2VzIG5vdCBuZWVkIHRoaXMgc3RlcC5cbiAgICAgKi9cbiAgICBjb25zdCBtID0gY3JlYXRlTWF0NCgpO1xuXG4gICAvLyBtYXRyaXggZm9yIGNvbnZlcnNpb24gZnJvbSBsb2NhdGlvbiB0byBzY3JlZW4gY29vcmRpbmF0ZXNcbiAgICBtYXQ0LnNjYWxlKG0sIG0sIFt0aGlzLndpZHRoIC8gMiwgLXRoaXMuaGVpZ2h0IC8gMiwgMV0pO1xuICAgIG1hdDQudHJhbnNsYXRlKG0sIG0sIFsxLCAtMSwgMF0pO1xuXG4gICAgLy8gU2NhbGUgd2l0aCB2aWV3cG9ydCB3aW5kb3cncyB3aWR0aCBhbmQgaGVpZ2h0IGluIHBpeGVsc1xuICAgIC8vIG1hdDQuc2NhbGUobSwgbSwgW3RoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCAxXSk7XG4gICAgLy8gQ29udmVydCB0byAoMCwgMSlcbiAgICAvLyBtYXQ0LnRyYW5zbGF0ZShtLCBtLCBbMC41LCAwLjUsIDBdKTtcbiAgICAvLyBtYXQ0LnNjYWxlKG0sIG0sIFswLjUsIDAuNSwgMV0pO1xuICAgIC8vIFByb2plY3QgdG8gY2xpcCBzcGFjZSAoLTEsIDEpXG4gICAgbWF0NC5tdWx0aXBseShtLCBtLCB0aGlzLnZpZXdQcm9qZWN0aW9uTWF0cml4KTtcblxuICAgIC8vIGNvbnNvbGUubG9nKGB2ZWMgJHtbdGhpcy53aWR0aCAvIDIsIHRoaXMuaGVpZ2h0IC8gMiwgMV19YCk7XG4gICAgLy8gY29uc29sZS5sb2coYFZpZXcgJHt0aGlzLnZpZXdNYXRyaXh9YCk7XG4gICAgLy8gY29uc29sZS5sb2coYFZQTSAke3ZwbX1gKTtcbiAgICAvLyBjb25zb2xlLmxvZyhgUGl4ZWwgJHttfWApO1xuXG4gICAgY29uc3QgbUludmVyc2UgPSBtYXQ0LmludmVydChjcmVhdGVNYXQ0KCksIG0pO1xuICAgIGlmICghbUludmVyc2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGl4ZWwgcHJvamVjdCBtYXRyaXggbm90IGludmVydGlibGUnKTtcbiAgICB9XG5cbiAgICB0aGlzLnBpeGVsUHJvamVjdGlvbk1hdHJpeCA9IG07XG4gICAgdGhpcy5waXhlbFVucHJvamVjdGlvbk1hdHJpeCA9IG1JbnZlcnNlO1xuXG4gICAgYXV0b2JpbmQodGhpcyk7XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSBjb21wbGV4aXR5ICovXG5cbiAgLy8gVHdvIHZpZXdwb3J0cyBhcmUgZXF1YWwgaWYgd2lkdGggYW5kIGhlaWdodCBhcmUgaWRlbnRpY2FsLCBhbmQgaWZcbiAgLy8gdGhlaXIgdmlldyBhbmQgcHJvamVjdGlvbiBtYXRyaWNlcyBhcmUgKGFwcHJveGltYXRlbHkpIGVxdWFsLlxuICBlcXVhbHModmlld3BvcnQpIHtcbiAgICBpZiAoISh2aWV3cG9ydCBpbnN0YW5jZW9mIFZpZXdwb3J0KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB2aWV3cG9ydC53aWR0aCA9PT0gdGhpcy53aWR0aCAmJlxuICAgICAgdmlld3BvcnQuaGVpZ2h0ID09PSB0aGlzLmhlaWdodCAmJlxuICAgICAgbWF0NC5lcXVhbHModmlld3BvcnQucHJvamVjdGlvbk1hdHJpeCwgdGhpcy5wcm9qZWN0aW9uTWF0cml4KSAmJlxuICAgICAgbWF0NC5lcXVhbHModmlld3BvcnQudmlld01hdHJpeCwgdGhpcy52aWV3TWF0cml4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9qZWN0cyB4eXogKHBvc3NpYmx5IGxhdGl0dWRlIGFuZCBsb25naXR1ZGUpIHRvIHBpeGVsIGNvb3JkaW5hdGVzIGluIHdpbmRvd1xuICAgKiB1c2luZyB2aWV3cG9ydCBwcm9qZWN0aW9uIHBhcmFtZXRlcnNcbiAgICogLSBbbG9uZ2l0dWRlLCBsYXRpdHVkZV0gdG8gW3gsIHldXG4gICAqIC0gW2xvbmdpdHVkZSwgbGF0aXR1ZGUsIFpdID0+IFt4LCB5LCB6XVxuICAgKiBOb3RlOiBCeSBkZWZhdWx0LCByZXR1cm5zIHRvcC1sZWZ0IGNvb3JkaW5hdGVzIGZvciBjYW52YXMvU1ZHIHR5cGUgcmVuZGVyXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGxuZ0xhdFogLSBbbG5nLCBsYXRdIG9yIFtsbmcsIGxhdCwgWl1cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLnRvcExlZnQ9dHJ1ZSAtIFdoZXRoZXIgcHJvamVjdGVkIGNvb3JkcyBhcmUgdG9wIGxlZnRcbiAgICogQHJldHVybiB7QXJyYXl9IC0gW3gsIHldIG9yIFt4LCB5LCB6XSBpbiB0b3AgbGVmdCBjb29yZHNcbiAgICovXG4gIHByb2plY3QoeHl6LCB7dG9wTGVmdCA9IGZhbHNlfSA9IHt9KSB7XG4gICAgY29uc3QgW3gwLCB5MCwgejAgPSAwXSA9IHh5ejtcbiAgICBhc3NlcnQoTnVtYmVyLmlzRmluaXRlKHgwKSAmJiBOdW1iZXIuaXNGaW5pdGUoeTApICYmIE51bWJlci5pc0Zpbml0ZSh6MCksIEVSUl9BUkdVTUVOVCk7XG5cbiAgICBjb25zdCBbWCwgWV0gPSB0aGlzLnByb2plY3RGbGF0KFt4MCwgeTBdKTtcbiAgICBjb25zdCB2ID0gdGhpcy50cmFuc2Zvcm1WZWN0b3IodGhpcy5waXhlbFByb2plY3Rpb25NYXRyaXgsIFtYLCBZLCB6MCwgMV0pO1xuXG4gICAgY29uc3QgW3gsIHldID0gdjtcbiAgICBjb25zdCB5MiA9IHRvcExlZnQgPyB0aGlzLmhlaWdodCAtIHkgOiB5O1xuICAgIHJldHVybiB4eXoubGVuZ3RoID09PSAyID8gW3gsIHkyXSA6IFt4LCB5MiwgMF07XG4gIH1cblxuICAvKipcbiAgICogVW5wcm9qZWN0IHBpeGVsIGNvb3JkaW5hdGVzIG9uIHNjcmVlbiBvbnRvIHdvcmxkIGNvb3JkaW5hdGVzLFxuICAgKiAocG9zc2libHkgW2xvbiwgbGF0XSkgb24gbWFwLlxuICAgKiAtIFt4LCB5XSA9PiBbbG5nLCBsYXRdXG4gICAqIC0gW3gsIHksIHpdID0+IFtsbmcsIGxhdCwgWl1cbiAgICogQHBhcmFtIHtBcnJheX0geHl6IC1cbiAgICogQHJldHVybiB7QXJyYXl9IC0gW2xuZywgbGF0LCBaXSBvciBbWCwgWSwgWl1cbiAgICovXG4gIHVucHJvamVjdCh4eXosIHt0b3BMZWZ0ID0gZmFsc2V9ID0ge30pIHtcbiAgICBjb25zdCBbeCwgeSwgdGFyZ2V0WiA9IDBdID0geHl6O1xuXG4gICAgY29uc3QgeTIgPSB0b3BMZWZ0ID8gdGhpcy5oZWlnaHQgLSB5IDogeTtcblxuICAgIC8vIHNpbmNlIHdlIGRvbid0IGtub3cgdGhlIGNvcnJlY3QgcHJvamVjdGVkIHogdmFsdWUgZm9yIHRoZSBwb2ludCxcbiAgICAvLyB1bnByb2plY3QgdHdvIHBvaW50cyB0byBnZXQgYSBsaW5lIGFuZCB0aGVuIGZpbmQgdGhlIHBvaW50IG9uIHRoYXQgbGluZSB3aXRoIHo9MFxuICAgIGNvbnN0IGNvb3JkMCA9IHRoaXMudHJhbnNmb3JtVmVjdG9yKHRoaXMucGl4ZWxVbnByb2plY3Rpb25NYXRyaXgsIFt4LCB5MiwgMCwgMV0pO1xuICAgIGNvbnN0IGNvb3JkMSA9IHRoaXMudHJhbnNmb3JtVmVjdG9yKHRoaXMucGl4ZWxVbnByb2plY3Rpb25NYXRyaXgsIFt4LCB5MiwgMSwgMV0pO1xuXG4gICAgY29uc3QgejAgPSBjb29yZDBbMl07XG4gICAgY29uc3QgejEgPSBjb29yZDFbMl07XG5cbiAgICBjb25zdCB0ID0gejAgPT09IHoxID8gMCA6ICh0YXJnZXRaIC0gejApIC8gKHoxIC0gejApO1xuICAgIGNvbnN0IHYgPSB2ZWMyLmxlcnAoW10sIGNvb3JkMCwgY29vcmQxLCB0KTtcblxuICAgIC8vIGNvbnNvbGUuZXJyb3IoYHVucHJvamVjdGluZyB0byBub24tbGluZWFyICR7dn08PSR7W3gsIHkyLCB0YXJnZXRaXX1gKTtcblxuICAgIGNvbnN0IHZVbnByb2plY3RlZCA9IHRoaXMudW5wcm9qZWN0RmxhdCh2KTtcbiAgICByZXR1cm4geHl6Lmxlbmd0aCA9PT0gMiA/IHZVbnByb2plY3RlZCA6IFt2VW5wcm9qZWN0ZWRbMF0sIHZVbnByb2plY3RlZFsxXSwgMF07XG4gIH1cblxuICAvLyBUT0RPIC0gcmVwbGFjZSB3aXRoIG1hdGguZ2xcbiAgdHJhbnNmb3JtVmVjdG9yKG1hdHJpeCwgdmVjdG9yKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdmVjNC50cmFuc2Zvcm1NYXQ0KFswLCAwLCAwLCAwXSwgdmVjdG9yLCBtYXRyaXgpO1xuICAgIGNvbnN0IHNjYWxlID0gMSAvIHJlc3VsdFszXTtcbiAgICB2ZWM0Lm11bHRpcGx5KHJlc3VsdCwgcmVzdWx0LCBbc2NhbGUsIHNjYWxlLCBzY2FsZSwgc2NhbGVdKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gTk9OX0xJTkVBUiBQUk9KRUNUSU9OIEhPT0tTXG4gIC8vIFVzZWQgZm9yIHdlYiBtZXJhY3RvciBwcm9qZWN0aW9uXG5cbiAgLyoqXG4gICAqIFByb2plY3QgW2xuZyxsYXRdIG9uIHNwaGVyZSBvbnRvIFt4LHldIG9uIDUxMio1MTIgTWVyY2F0b3IgWm9vbSAwIHRpbGUuXG4gICAqIFBlcmZvcm1zIHRoZSBub25saW5lYXIgcGFydCBvZiB0aGUgd2ViIG1lcmNhdG9yIHByb2plY3Rpb24uXG4gICAqIFJlbWFpbmluZyBwcm9qZWN0aW9uIGlzIGRvbmUgd2l0aCA0eDQgbWF0cmljZXMgd2hpY2ggYWxzbyBoYW5kbGVzXG4gICAqIHBlcnNwZWN0aXZlLlxuICAgKiBAcGFyYW0ge0FycmF5fSBsbmdMYXQgLSBbbG5nLCBsYXRdIGNvb3JkaW5hdGVzXG4gICAqICAgU3BlY2lmaWVzIGEgcG9pbnQgb24gdGhlIHNwaGVyZSB0byBwcm9qZWN0IG9udG8gdGhlIG1hcC5cbiAgICogQHJldHVybiB7QXJyYXl9IFt4LHldIGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgcHJvamVjdEZsYXQoW3gsIHldLCBzY2FsZSA9IHRoaXMuc2NhbGUpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvamVjdEZsYXQoLi4uYXJndW1lbnRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnByb2plY3Qgd29ybGQgcG9pbnQgW3gseV0gb24gbWFwIG9udG8ge2xhdCwgbG9ufSBvbiBzcGhlcmVcbiAgICogQHBhcmFtIHtvYmplY3R8VmVjdG9yfSB4eSAtIG9iamVjdCB3aXRoIHt4LHl9IG1lbWJlcnNcbiAgICogIHJlcHJlc2VudGluZyBwb2ludCBvbiBwcm9qZWN0ZWQgbWFwIHBsYW5lXG4gICAqIEByZXR1cm4ge0dlb0Nvb3JkaW5hdGVzfSAtIG9iamVjdCB3aXRoIHtsYXQsbG9ufSBvZiBwb2ludCBvbiBzcGhlcmUuXG4gICAqICAgSGFzIHRvQXJyYXkgbWV0aG9kIGlmIHlvdSBuZWVkIGEgR2VvSlNPTiBBcnJheS5cbiAgICogICBQZXIgY2FydG9ncmFwaGljIHRyYWRpdGlvbiwgbGF0IGFuZCBsb24gYXJlIHNwZWNpZmllZCBhcyBkZWdyZWVzLlxuICAgKi9cbiAgdW5wcm9qZWN0RmxhdCh4eXosIHNjYWxlID0gdGhpcy5zY2FsZSkge1xuICAgIHJldHVybiB0aGlzLl91bnByb2plY3RGbGF0KC4uLmFyZ3VtZW50cyk7XG4gIH1cblxuICBnZXRNYXRyaWNlcyh7bW9kZWxNYXRyaXggPSBudWxsfSA9IHt9KSB7XG4gICAgbGV0IG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXggPSB0aGlzLnZpZXdQcm9qZWN0aW9uTWF0cml4O1xuICAgIGxldCBwaXhlbFByb2plY3Rpb25NYXRyaXggPSB0aGlzLnBpeGVsUHJvamVjdGlvbk1hdHJpeDtcbiAgICBsZXQgcGl4ZWxVbnByb2plY3Rpb25NYXRyaXggPSB0aGlzLnBpeGVsVW5wcm9qZWN0aW9uTWF0cml4O1xuXG4gICAgaWYgKG1vZGVsTWF0cml4KSB7XG4gICAgICBtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4ID0gbWF0NC5tdWx0aXBseShbXSwgdGhpcy52aWV3UHJvamVjdGlvbk1hdHJpeCwgbW9kZWxNYXRyaXgpO1xuICAgICAgcGl4ZWxQcm9qZWN0aW9uTWF0cml4ID0gbWF0NC5tdWx0aXBseShbXSwgdGhpcy5waXhlbFByb2plY3Rpb25NYXRyaXgsIG1vZGVsTWF0cml4KTtcbiAgICAgIHBpeGVsVW5wcm9qZWN0aW9uTWF0cml4ID0gbWF0NC5pbnZlcnQoW10sIHBpeGVsUHJvamVjdGlvbk1hdHJpeCk7XG4gICAgfVxuXG4gICAgY29uc3QgbWF0cmljZXMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXgsXG4gICAgICB2aWV3UHJvamVjdGlvbk1hdHJpeDogdGhpcy52aWV3UHJvamVjdGlvbk1hdHJpeCxcbiAgICAgIHZpZXdNYXRyaXg6IHRoaXMudmlld01hdHJpeCxcbiAgICAgIHByb2plY3Rpb25NYXRyaXg6IHRoaXMucHJvamVjdGlvbk1hdHJpeCxcblxuICAgICAgLy8gcHJvamVjdC91bnByb2plY3QgYmV0d2VlbiBwaXhlbHMgYW5kIHdvcmxkXG4gICAgICBwaXhlbFByb2plY3Rpb25NYXRyaXgsXG4gICAgICBwaXhlbFVucHJvamVjdGlvbk1hdHJpeCxcblxuICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgc2NhbGU6IHRoaXMuc2NhbGVcbiAgICB9LFxuXG4gICAgICAvLyBTdWJjbGFzcyBjYW4gYWRkIGFkZGl0aW9uYWwgcGFyYW1zXG4gICAgICAvLyBUT0RPIC0gRnJhZ2lsZTogYmV0dGVyIHRvIG1ha2UgYmFzZSBWaWV3cG9ydCBjbGFzcyBhd2FyZSBvZiBhbGwgcGFyYW1zXG4gICAgICB0aGlzLl9nZXRQYXJhbXMoKVxuICAgICk7XG5cbiAgICByZXR1cm4gbWF0cmljZXM7XG4gIH1cblxuICAvLyBJTlRFUk5BTCBNRVRIT0RTXG5cbiAgLy8gQ2FuIGJlIHN1YmNsYXNzZWQgdG8gYWRkIGFkZGl0aW9uYWwgZmllbGRzIHRvIGBnZXRNYXRyaWNlc2BcbiAgX2dldFBhcmFtcygpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbn1cblxuLy8gSGVscGVyLCBhdm9pZHMgbG93LXByZWNpc2lvbiAzMiBiaXQgbWF0cmljZXMgZnJvbSBnbC1tYXRyaXggbWF0NC5jcmVhdGUoKVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU1hdDQoKSB7XG4gIHJldHVybiBbMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMV07XG59XG4iXX0=