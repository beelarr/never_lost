'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // View and Projection Matrix management

// gl-matrix is a large dependency for a small module.
// However since it is used by mapbox etc, it should already be present
// in most target application bundles.


exports.createMat4 = createMat4;

var _glMatrix = require('gl-matrix');

var _autobind = require('./autobind');

var _autobind2 = _interopRequireDefault(_autobind);

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var IDENTITY = createMat4();

var ERR_ARGUMENT = 'Illegal argument to Viewport';

var Viewport = function () {
  /**
   * @classdesc
   * Manages coordinate system transformations for deck.gl.
   *
   * Note: The Viewport is immutable in the sense that it only has accessors.
   * A new viewport instance should be created if any parameters have changed.
   *
   * @class
   * @param {Object} opt - options
   * @param {Boolean} mercator=true - Whether to use mercator projection
   *
   * @param {Number} opt.width=1 - Width of "viewport" or window
   * @param {Number} opt.height=1 - Height of "viewport" or window
   * @param {Array} opt.center=[0, 0] - Center of viewport
   *   [longitude, latitude] or [x, y]
   * @param {Number} opt.scale=1 - Either use scale or zoom
   * @param {Number} opt.pitch=0 - Camera angle in degrees (0 is straight down)
   * @param {Number} opt.bearing=0 - Map rotation in degrees (0 means north is up)
   * @param {Number} opt.altitude= - Altitude of camera in screen units
   *
   * Web mercator projection short-hand parameters
   * @param {Number} opt.latitude - Center of viewport on map (alternative to opt.center)
   * @param {Number} opt.longitude - Center of viewport on map (alternative to opt.center)
   * @param {Number} opt.zoom - Scale = Math.pow(2,zoom) on map (alternative to opt.scale)
   */
  /* eslint-disable complexity */
  function Viewport() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$width = _ref.width,
        width = _ref$width === undefined ? 1 : _ref$width,
        _ref$height = _ref.height,
        height = _ref$height === undefined ? 1 : _ref$height,
        _ref$viewMatrix = _ref.viewMatrix,
        viewMatrix = _ref$viewMatrix === undefined ? IDENTITY : _ref$viewMatrix,
        _ref$projectionMatrix = _ref.projectionMatrix,
        projectionMatrix = _ref$projectionMatrix === undefined ? IDENTITY : _ref$projectionMatrix;

    _classCallCheck(this, Viewport);

    // Silently allow apps to send in 0,0
    this.width = width || 1;
    this.height = height || 1;
    this.scale = 1;

    this.viewMatrix = viewMatrix;
    this.projectionMatrix = projectionMatrix;

    // Note: As usual, matrix operations should be applied in "reverse" order
    // since vectors will be multiplied in from the right during transformation
    var vpm = createMat4();
    _glMatrix.mat4.multiply(vpm, vpm, this.projectionMatrix);
    _glMatrix.mat4.multiply(vpm, vpm, this.viewMatrix);
    this.viewProjectionMatrix = vpm;

    // Calculate matrices and scales needed for projection
    /**
     * Builds matrices that converts preprojected lngLats to screen pixels
     * and vice versa.
     * Note: Currently returns bottom-left coordinates!
     * Note: Starts with the GL projection matrix and adds steps to the
     *       scale and translate that matrix onto the window.
     * Note: WebGL controls clip space to screen projection with gl.viewport
     *       and does not need this step.
     */
    var m = createMat4();

    // matrix for conversion from location to screen coordinates
    _glMatrix.mat4.scale(m, m, [this.width / 2, -this.height / 2, 1]);
    _glMatrix.mat4.translate(m, m, [1, -1, 0]);

    // Scale with viewport window's width and height in pixels
    // mat4.scale(m, m, [this.width, this.height, 1]);
    // Convert to (0, 1)
    // mat4.translate(m, m, [0.5, 0.5, 0]);
    // mat4.scale(m, m, [0.5, 0.5, 1]);
    // Project to clip space (-1, 1)
    _glMatrix.mat4.multiply(m, m, this.viewProjectionMatrix);

    // console.log(`vec ${[this.width / 2, this.height / 2, 1]}`);
    // console.log(`View ${this.viewMatrix}`);
    // console.log(`VPM ${vpm}`);
    // console.log(`Pixel ${m}`);

    var mInverse = _glMatrix.mat4.invert(createMat4(), m);
    if (!mInverse) {
      throw new Error('Pixel project matrix not invertible');
    }

    this.pixelProjectionMatrix = m;
    this.pixelUnprojectionMatrix = mInverse;

    (0, _autobind2.default)(this);
  }
  /* eslint-enable complexity */

  // Two viewports are equal if width and height are identical, and if
  // their view and projection matrices are (approximately) equal.


  _createClass(Viewport, [{
    key: 'equals',
    value: function equals(viewport) {
      if (!(viewport instanceof Viewport)) {
        return false;
      }

      return viewport.width === this.width && viewport.height === this.height && _glMatrix.mat4.equals(viewport.projectionMatrix, this.projectionMatrix) && _glMatrix.mat4.equals(viewport.viewMatrix, this.viewMatrix);
    }

    /**
     * Projects xyz (possibly latitude and longitude) to pixel coordinates in window
     * using viewport projection parameters
     * - [longitude, latitude] to [x, y]
     * - [longitude, latitude, Z] => [x, y, z]
     * Note: By default, returns top-left coordinates for canvas/SVG type render
     *
     * @param {Array} lngLatZ - [lng, lat] or [lng, lat, Z]
     * @param {Object} opts - options
     * @param {Object} opts.topLeft=true - Whether projected coords are top left
     * @return {Array} - [x, y] or [x, y, z] in top left coords
     */

  }, {
    key: 'project',
    value: function project(xyz) {
      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref2$topLeft = _ref2.topLeft,
          topLeft = _ref2$topLeft === undefined ? false : _ref2$topLeft;

      var _xyz = _slicedToArray(xyz, 3),
          x0 = _xyz[0],
          y0 = _xyz[1],
          _xyz$ = _xyz[2],
          z0 = _xyz$ === undefined ? 0 : _xyz$;

      (0, _assert2.default)(Number.isFinite(x0) && Number.isFinite(y0) && Number.isFinite(z0), ERR_ARGUMENT);

      var _projectFlat = this.projectFlat([x0, y0]),
          _projectFlat2 = _slicedToArray(_projectFlat, 2),
          X = _projectFlat2[0],
          Y = _projectFlat2[1];

      var v = this.transformVector(this.pixelProjectionMatrix, [X, Y, z0, 1]);

      var _v = _slicedToArray(v, 2),
          x = _v[0],
          y = _v[1];

      var y2 = topLeft ? this.height - y : y;
      return xyz.length === 2 ? [x, y2] : [x, y2, 0];
    }

    /**
     * Unproject pixel coordinates on screen onto world coordinates,
     * (possibly [lon, lat]) on map.
     * - [x, y] => [lng, lat]
     * - [x, y, z] => [lng, lat, Z]
     * @param {Array} xyz -
     * @return {Array} - [lng, lat, Z] or [X, Y, Z]
     */

  }, {
    key: 'unproject',
    value: function unproject(xyz) {
      var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref3$topLeft = _ref3.topLeft,
          topLeft = _ref3$topLeft === undefined ? false : _ref3$topLeft;

      var _xyz2 = _slicedToArray(xyz, 3),
          x = _xyz2[0],
          y = _xyz2[1],
          _xyz2$ = _xyz2[2],
          targetZ = _xyz2$ === undefined ? 0 : _xyz2$;

      var y2 = topLeft ? this.height - y : y;

      // since we don't know the correct projected z value for the point,
      // unproject two points to get a line and then find the point on that line with z=0
      var coord0 = this.transformVector(this.pixelUnprojectionMatrix, [x, y2, 0, 1]);
      var coord1 = this.transformVector(this.pixelUnprojectionMatrix, [x, y2, 1, 1]);

      var z0 = coord0[2];
      var z1 = coord1[2];

      var t = z0 === z1 ? 0 : (targetZ - z0) / (z1 - z0);
      var v = _glMatrix.vec2.lerp([], coord0, coord1, t);

      // console.error(`unprojecting to non-linear ${v}<=${[x, y2, targetZ]}`);

      var vUnprojected = this.unprojectFlat(v);
      return xyz.length === 2 ? vUnprojected : [vUnprojected[0], vUnprojected[1], 0];
    }

    // TODO - replace with math.gl

  }, {
    key: 'transformVector',
    value: function transformVector(matrix, vector) {
      var result = _glMatrix.vec4.transformMat4([0, 0, 0, 0], vector, matrix);
      var scale = 1 / result[3];
      _glMatrix.vec4.multiply(result, result, [scale, scale, scale, scale]);
      return result;
    }

    // NON_LINEAR PROJECTION HOOKS
    // Used for web meractor projection

    /**
     * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.
     * Performs the nonlinear part of the web mercator projection.
     * Remaining projection is done with 4x4 matrices which also handles
     * perspective.
     * @param {Array} lngLat - [lng, lat] coordinates
     *   Specifies a point on the sphere to project onto the map.
     * @return {Array} [x,y] coordinates.
     */

  }, {
    key: 'projectFlat',
    value: function projectFlat(_ref4) {
      var _ref5 = _slicedToArray(_ref4, 2),
          x = _ref5[0],
          y = _ref5[1];

      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      return this._projectFlat.apply(this, arguments);
    }

    /**
     * Unproject world point [x,y] on map onto {lat, lon} on sphere
     * @param {object|Vector} xy - object with {x,y} members
     *  representing point on projected map plane
     * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.
     *   Has toArray method if you need a GeoJSON Array.
     *   Per cartographic tradition, lat and lon are specified as degrees.
     */

  }, {
    key: 'unprojectFlat',
    value: function unprojectFlat(xyz) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      return this._unprojectFlat.apply(this, arguments);
    }
  }, {
    key: 'getMatrices',
    value: function getMatrices() {
      var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref6$modelMatrix = _ref6.modelMatrix,
          modelMatrix = _ref6$modelMatrix === undefined ? null : _ref6$modelMatrix;

      var modelViewProjectionMatrix = this.viewProjectionMatrix;
      var pixelProjectionMatrix = this.pixelProjectionMatrix;
      var pixelUnprojectionMatrix = this.pixelUnprojectionMatrix;

      if (modelMatrix) {
        modelViewProjectionMatrix = _glMatrix.mat4.multiply([], this.viewProjectionMatrix, modelMatrix);
        pixelProjectionMatrix = _glMatrix.mat4.multiply([], this.pixelProjectionMatrix, modelMatrix);
        pixelUnprojectionMatrix = _glMatrix.mat4.invert([], pixelProjectionMatrix);
      }

      var matrices = Object.assign({
        modelViewProjectionMatrix: modelViewProjectionMatrix,
        viewProjectionMatrix: this.viewProjectionMatrix,
        viewMatrix: this.viewMatrix,
        projectionMatrix: this.projectionMatrix,

        // project/unproject between pixels and world
        pixelProjectionMatrix: pixelProjectionMatrix,
        pixelUnprojectionMatrix: pixelUnprojectionMatrix,

        width: this.width,
        height: this.height,
        scale: this.scale
      },

      // Subclass can add additional params
      // TODO - Fragile: better to make base Viewport class aware of all params
      this._getParams());

      return matrices;
    }

    // INTERNAL METHODS

    // Can be subclassed to add additional fields to `getMatrices`

  }, {
    key: '_getParams',
    value: function _getParams() {
      return {};
    }
  }]);

  return Viewport;
}();

// Helper, avoids low-precision 32 bit matrices from gl-matrix mat4.create()


exports.default = Viewport;
function createMat4() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy92aWV3cG9ydC5qcyJdLCJuYW1lcyI6WyJjcmVhdGVNYXQ0IiwiSURFTlRJVFkiLCJFUlJfQVJHVU1FTlQiLCJWaWV3cG9ydCIsIndpZHRoIiwiaGVpZ2h0Iiwidmlld01hdHJpeCIsInByb2plY3Rpb25NYXRyaXgiLCJzY2FsZSIsInZwbSIsIm11bHRpcGx5Iiwidmlld1Byb2plY3Rpb25NYXRyaXgiLCJtIiwidHJhbnNsYXRlIiwibUludmVyc2UiLCJpbnZlcnQiLCJFcnJvciIsInBpeGVsUHJvamVjdGlvbk1hdHJpeCIsInBpeGVsVW5wcm9qZWN0aW9uTWF0cml4Iiwidmlld3BvcnQiLCJlcXVhbHMiLCJ4eXoiLCJ0b3BMZWZ0IiwieDAiLCJ5MCIsInowIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJwcm9qZWN0RmxhdCIsIlgiLCJZIiwidiIsInRyYW5zZm9ybVZlY3RvciIsIngiLCJ5IiwieTIiLCJsZW5ndGgiLCJ0YXJnZXRaIiwiY29vcmQwIiwiY29vcmQxIiwiejEiLCJ0IiwibGVycCIsInZVbnByb2plY3RlZCIsInVucHJvamVjdEZsYXQiLCJtYXRyaXgiLCJ2ZWN0b3IiLCJyZXN1bHQiLCJ0cmFuc2Zvcm1NYXQ0IiwiX3Byb2plY3RGbGF0IiwiYXJndW1lbnRzIiwiX3VucHJvamVjdEZsYXQiLCJtb2RlbE1hdHJpeCIsIm1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXgiLCJtYXRyaWNlcyIsIk9iamVjdCIsImFzc2lnbiIsIl9nZXRQYXJhbXMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O3FqQkFBQTs7QUFFQTtBQUNBO0FBQ0E7OztRQXNQZ0JBLFUsR0FBQUEsVTs7QUFyUGhCOztBQUNBOzs7O0FBQ0E7Ozs7Ozs7O0FBRUEsSUFBTUMsV0FBV0QsWUFBakI7O0FBRUEsSUFBTUUsZUFBZSw4QkFBckI7O0lBRXFCQyxRO0FBQ25COzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeUJBO0FBQ0Esc0JBT1E7QUFBQSxtRkFBSixFQUFJO0FBQUEsMEJB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QXpCLEVBQTRCLENBQTVCLEVBQStCLENBQS9CLEVBQWtDLENBQWxDLEVBQXFDLENBQXJDLEVBQXdDLENBQXhDLEVBQTJDLENBQTNDLEVBQThDLENBQTlDLENBQVA7QUFDRCIsImZpbGUiOiJ2aWV3cG9ydC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIFZpZXcgYW5kIFByb2plY3Rpb24gTWF0cml4IG1hbmFnZW1lbnRcblxuLy8gZ2wtbWF0cml4IGlzIGEgbGFyZ2UgZGVwZW5kZW5jeSBmb3IgYSBzbWFsbCBtb2R1bGUuXG4vLyBIb3dldmVyIHNpbmNlIGl0IGlzIHVzZWQgYnkgbWFwYm94IGV0YywgaXQgc2hvdWxkIGFscmVhZHkgYmUgcHJlc2VudFxuLy8gaW4gbW9zdCB0YXJnZXQgYXBwbGljYXRpb24gYnVuZGxlcy5cbmltcG9ydCB7bWF0NCwgdmVjNCwgdmVjMn0gZnJvbSAnZ2wtbWF0cml4JztcbmltcG9ydCBhdXRvYmluZCBmcm9tICcuL2F1dG9iaW5kJztcbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcblxuY29uc3QgSURFTlRJVFkgPSBjcmVhdGVNYXQ0KCk7XG5cbmNvbnN0IEVSUl9BUkdVTUVOVCA9ICdJbGxlZ2FsIGFyZ3VtZW50IHRvIFZpZXdwb3J0JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmlld3BvcnQge1xuICAvKipcbiAgICogQGNsYXNzZGVzY1xuICAgKiBNYW5hZ2VzIGNvb3JkaW5hdGUgc3lzdGVtIHRyYW5zZm9ybWF0aW9ucyBmb3IgZGVjay5nbC5cbiAgICpcbiAgICogTm90ZTogVGhlIFZpZXdwb3J0IGlzIGltbXV0YWJsZSBpbiB0aGUgc2Vuc2UgdGhhdCBpdCBvbmx5IGhhcyBhY2Nlc3NvcnMuXG4gICAqIEEgbmV3IHZpZXdwb3J0IGluc3RhbmNlIHNob3VsZCBiZSBjcmVhdGVkIGlmIGFueSBwYXJhbWV0ZXJzIGhhdmUgY2hhbmdlZC5cbiAgICpcbiAgICogQGNsYXNzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHQgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gbWVyY2F0b3I9dHJ1ZSAtIFdoZXRoZXIgdG8gdXNlIG1lcmNhdG9yIHByb2plY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC53aWR0aD0xIC0gV2lkdGggb2YgXCJ2aWV3cG9ydFwiIG9yIHdpbmRvd1xuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LmhlaWdodD0xIC0gSGVpZ2h0IG9mIFwidmlld3BvcnRcIiBvciB3aW5kb3dcbiAgICogQHBhcmFtIHtBcnJheX0gb3B0LmNlbnRlcj1bMCwgMF0gLSBDZW50ZXIgb2Ygdmlld3BvcnRcbiAgICogICBbbG9uZ2l0dWRlLCBsYXRpdHVkZV0gb3IgW3gsIHldXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQuc2NhbGU9MSAtIEVpdGhlciB1c2Ugc2NhbGUgb3Igem9vbVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LnBpdGNoPTAgLSBDYW1lcmEgYW5nbGUgaW4gZGVncmVlcyAoMCBpcyBzdHJhaWdodCBkb3duKVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LmJlYXJpbmc9MCAtIE1hcCByb3RhdGlvbiBpbiBkZWdyZWVzICgwIG1lYW5zIG5vcnRoIGlzIHVwKVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LmFsdGl0dWRlPSAtIEFsdGl0dWRlIG9mIGNhbWVyYSBpbiBzY3JlZW4gdW5pdHNcbiAgICpcbiAgICogV2ViIG1lcmNhdG9yIHByb2plY3Rpb24gc2hvcnQtaGFuZCBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQubGF0aXR1ZGUgLSBDZW50ZXIgb2Ygdmlld3BvcnQgb24gbWFwIChhbHRlcm5hdGl2ZSB0byBvcHQuY2VudGVyKVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LmxvbmdpdHVkZSAtIENlbnRlciBvZiB2aWV3cG9ydCBvbiBtYXAgKGFsdGVybmF0aXZlIHRvIG9wdC5jZW50ZXIpXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQuem9vbSAtIFNjYWxlID0gTWF0aC5wb3coMix6b29tKSBvbiBtYXAgKGFsdGVybmF0aXZlIHRvIG9wdC5zY2FsZSlcbiAgICovXG4gIC8qIGVzbGludC1kaXNhYmxlIGNvbXBsZXhpdHkgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIC8vIFdpbmRvdyB3aWR0aC9oZWlnaHQgaW4gcGl4ZWxzIChmb3IgcGl4ZWwgcHJvamVjdGlvbilcbiAgICB3aWR0aCA9IDEsXG4gICAgaGVpZ2h0ID0gMSxcbiAgICAvLyBEZXNjXG4gICAgdmlld01hdHJpeCA9IElERU5USVRZLFxuICAgIHByb2plY3Rpb25NYXRyaXggPSBJREVOVElUWVxuICB9ID0ge30pIHtcbiAgICAvLyBTaWxlbnRseSBhbGxvdyBhcHBzIHRvIHNlbmQgaW4gMCwwXG4gICAgdGhpcy53aWR0aCA9IHdpZHRoIHx8IDE7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgfHwgMTtcbiAgICB0aGlzLnNjYWxlID0gMTtcblxuICAgIHRoaXMudmlld01hdHJpeCA9IHZpZXdNYXRyaXg7XG4gICAgdGhpcy5wcm9qZWN0aW9uTWF0cml4ID0gcHJvamVjdGlvbk1hdHJpeDtcblxuICAgIC8vIE5vdGU6IEFzIHVzdWFsLCBtYXRyaXggb3BlcmF0aW9ucyBzaG91bGQgYmUgYXBwbGllZCBpbiBcInJldmVyc2VcIiBvcmRlclxuICAgIC8vIHNpbmNlIHZlY3RvcnMgd2lsbCBiZSBtdWx0aXBsaWVkIGluIGZyb20gdGhlIHJpZ2h0IGR1cmluZyB0cmFuc2Zvcm1hdGlvblxuICAgIGNvbnN0IHZwbSA9IGNyZWF0ZU1hdDQoKTtcbiAgICBtYXQ0Lm11bHRpcGx5KHZwbSwgdnBtLCB0aGlzLnByb2plY3Rpb25NYXRyaXgpO1xuICAgIG1hdDQubXVsdGlwbHkodnBtLCB2cG0sIHRoaXMudmlld01hdHJpeCk7XG4gICAgdGhpcy52aWV3UHJvamVjdGlvbk1hdHJpeCA9IHZwbTtcblxuICAgIC8vIENhbGN1bGF0ZSBtYXRyaWNlcyBhbmQgc2NhbGVzIG5lZWRlZCBmb3IgcHJvamVjdGlvblxuICAgIC8qKlxuICAgICAqIEJ1aWxkcyBtYXRyaWNlcyB0aGF0IGNvbnZlcnRzIHByZXByb2plY3RlZCBsbmdMYXRzIHRvIHNjcmVlbiBwaXhlbHNcbiAgICAgKiBhbmQgdmljZSB2ZXJzYS5cbiAgICAgKiBOb3RlOiBDdXJyZW50bHkgcmV0dXJucyBib3R0b20tbGVmdCBjb29yZGluYXRlcyFcbiAgICAgKiBOb3RlOiBTdGFydHMgd2l0aCB0aGUgR0wgcHJvamVjdGlvbiBtYXRyaXggYW5kIGFkZHMgc3RlcHMgdG8gdGhlXG4gICAgICogICAgICAgc2NhbGUgYW5kIHRyYW5zbGF0ZSB0aGF0IG1hdHJpeCBvbnRvIHRoZSB3aW5kb3cuXG4gICAgICogTm90ZTogV2ViR0wgY29udHJvbHMgY2xpcCBzcGFjZSB0byBzY3JlZW4gcHJvamVjdGlvbiB3aXRoIGdsLnZpZXdwb3J0XG4gICAgICogICAgICAgYW5kIGRvZXMgbm90IG5lZWQgdGhpcyBzdGVwLlxuICAgICAqL1xuICAgIGNvbnN0IG0gPSBjcmVhdGVNYXQ0KCk7XG5cbiAgIC8vIG1hdHJpeCBmb3IgY29udmVyc2lvbiBmcm9tIGxvY2F0aW9uIHRvIHNjcmVlbiBjb29yZGluYXRlc1xuICAgIG1hdDQuc2NhbGUobSwgbSwgW3RoaXMud2lkdGggLyAyLCAtdGhpcy5oZWlnaHQgLyAyLCAxXSk7XG4gICAgbWF0NC50cmFuc2xhdGUobSwgbSwgWzEsIC0xLCAwXSk7XG5cbiAgICAvLyBTY2FsZSB3aXRoIHZpZXdwb3J0IHdpbmRvdydzIHdpZHRoIGFuZCBoZWlnaHQgaW4gcGl4ZWxzXG4gICAgLy8gbWF0NC5zY2FsZShtLCBtLCBbdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIDFdKTtcbiAgICAvLyBDb252ZXJ0IHRvICgwLCAxKVxuICAgIC8vIG1hdDQudHJhbnNsYXRlKG0sIG0sIFswLjUsIDAuNSwgMF0pO1xuICAgIC8vIG1hdDQuc2NhbGUobSwgbSwgWzAuNSwgMC41LCAxXSk7XG4gICAgLy8gUHJvamVjdCB0byBjbGlwIHNwYWNlICgtMSwgMSlcbiAgICBtYXQ0Lm11bHRpcGx5KG0sIG0sIHRoaXMudmlld1Byb2plY3Rpb25NYXRyaXgpO1xuXG4gICAgLy8gY29uc29sZS5sb2coYHZlYyAke1t0aGlzLndpZHRoIC8gMiwgdGhpcy5oZWlnaHQgLyAyLCAxXX1gKTtcbiAgICAvLyBjb25zb2xlLmxvZyhgVmlldyAke3RoaXMudmlld01hdHJpeH1gKTtcbiAgICAvLyBjb25zb2xlLmxvZyhgVlBNICR7dnBtfWApO1xuICAgIC8vIGNvbnNvbGUubG9nKGBQaXhlbCAke219YCk7XG5cbiAgICBjb25zdCBtSW52ZXJzZSA9IG1hdDQuaW52ZXJ0KGNyZWF0ZU1hdDQoKSwgbSk7XG4gICAgaWYgKCFtSW52ZXJzZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQaXhlbCBwcm9qZWN0IG1hdHJpeCBub3QgaW52ZXJ0aWJsZScpO1xuICAgIH1cblxuICAgIHRoaXMucGl4ZWxQcm9qZWN0aW9uTWF0cml4ID0gbTtcbiAgICB0aGlzLnBpeGVsVW5wcm9qZWN0aW9uTWF0cml4ID0gbUludmVyc2U7XG5cbiAgICBhdXRvYmluZCh0aGlzKTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIGNvbXBsZXhpdHkgKi9cblxuICAvLyBUd28gdmlld3BvcnRzIGFyZSBlcXVhbCBpZiB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBpZGVudGljYWwsIGFuZCBpZlxuICAvLyB0aGVpciB2aWV3IGFuZCBwcm9qZWN0aW9uIG1hdHJpY2VzIGFyZSAoYXBwcm94aW1hdGVseSkgZXF1YWwuXG4gIGVxdWFscyh2aWV3cG9ydCkge1xuICAgIGlmICghKHZpZXdwb3J0IGluc3RhbmNlb2YgVmlld3BvcnQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZpZXdwb3J0LndpZHRoID09PSB0aGlzLndpZHRoICYmXG4gICAgICB2aWV3cG9ydC5oZWlnaHQgPT09IHRoaXMuaGVpZ2h0ICYmXG4gICAgICBtYXQ0LmVxdWFscyh2aWV3cG9ydC5wcm9qZWN0aW9uTWF0cml4LCB0aGlzLnByb2plY3Rpb25NYXRyaXgpICYmXG4gICAgICBtYXQ0LmVxdWFscyh2aWV3cG9ydC52aWV3TWF0cml4LCB0aGlzLnZpZXdNYXRyaXgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb2plY3RzIHh5eiAocG9zc2libHkgbGF0aXR1ZGUgYW5kIGxvbmdpdHVkZSkgdG8gcGl4ZWwgY29vcmRpbmF0ZXMgaW4gd2luZG93XG4gICAqIHVzaW5nIHZpZXdwb3J0IHByb2plY3Rpb24gcGFyYW1ldGVyc1xuICAgKiAtIFtsb25naXR1ZGUsIGxhdGl0dWRlXSB0byBbeCwgeV1cbiAgICogLSBbbG9uZ2l0dWRlLCBsYXRpdHVkZSwgWl0gPT4gW3gsIHksIHpdXG4gICAqIE5vdGU6IEJ5IGRlZmF1bHQsIHJldHVybnMgdG9wLWxlZnQgY29vcmRpbmF0ZXMgZm9yIGNhbnZhcy9TVkcgdHlwZSByZW5kZXJcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gbG5nTGF0WiAtIFtsbmcsIGxhdF0gb3IgW2xuZywgbGF0LCBaXVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMudG9wTGVmdD10cnVlIC0gV2hldGhlciBwcm9qZWN0ZWQgY29vcmRzIGFyZSB0b3AgbGVmdFxuICAgKiBAcmV0dXJuIHtBcnJheX0gLSBbeCwgeV0gb3IgW3gsIHksIHpdIGluIHRvcCBsZWZ0IGNvb3Jkc1xuICAgKi9cbiAgcHJvamVjdCh4eXosIHt0b3BMZWZ0ID0gZmFsc2V9ID0ge30pIHtcbiAgICBjb25zdCBbeDAsIHkwLCB6MCA9IDBdID0geHl6O1xuICAgIGFzc2VydChOdW1iZXIuaXNGaW5pdGUoeDApICYmIE51bWJlci5pc0Zpbml0ZSh5MCkgJiYgTnVtYmVyLmlzRmluaXRlKHowKSwgRVJSX0FSR1VNRU5UKTtcblxuICAgIGNvbnN0IFtYLCBZXSA9IHRoaXMucHJvamVjdEZsYXQoW3gwLCB5MF0pO1xuICAgIGNvbnN0IHYgPSB0aGlzLnRyYW5zZm9ybVZlY3Rvcih0aGlzLnBpeGVsUHJvamVjdGlvbk1hdHJpeCwgW1gsIFksIHowLCAxXSk7XG5cbiAgICBjb25zdCBbeCwgeV0gPSB2O1xuICAgIGNvbnN0IHkyID0gdG9wTGVmdCA/IHRoaXMuaGVpZ2h0IC0geSA6IHk7XG4gICAgcmV0dXJuIHh5ei5sZW5ndGggPT09IDIgPyBbeCwgeTJdIDogW3gsIHkyLCAwXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnByb2plY3QgcGl4ZWwgY29vcmRpbmF0ZXMgb24gc2NyZWVuIG9udG8gd29ybGQgY29vcmRpbmF0ZXMsXG4gICAqIChwb3NzaWJseSBbbG9uLCBsYXRdKSBvbiBtYXAuXG4gICAqIC0gW3gsIHldID0+IFtsbmcsIGxhdF1cbiAgICogLSBbeCwgeSwgel0gPT4gW2xuZywgbGF0LCBaXVxuICAgKiBAcGFyYW0ge0FycmF5fSB4eXogLVxuICAgKiBAcmV0dXJuIHtBcnJheX0gLSBbbG5nLCBsYXQsIFpdIG9yIFtYLCBZLCBaXVxuICAgKi9cbiAgdW5wcm9qZWN0KHh5eiwge3RvcExlZnQgPSBmYWxzZX0gPSB7fSkge1xuICAgIGNvbnN0IFt4LCB5LCB0YXJnZXRaID0gMF0gPSB4eXo7XG5cbiAgICBjb25zdCB5MiA9IHRvcExlZnQgPyB0aGlzLmhlaWdodCAtIHkgOiB5O1xuXG4gICAgLy8gc2luY2Ugd2UgZG9uJ3Qga25vdyB0aGUgY29ycmVjdCBwcm9qZWN0ZWQgeiB2YWx1ZSBmb3IgdGhlIHBvaW50LFxuICAgIC8vIHVucHJvamVjdCB0d28gcG9pbnRzIHRvIGdldCBhIGxpbmUgYW5kIHRoZW4gZmluZCB0aGUgcG9pbnQgb24gdGhhdCBsaW5lIHdpdGggej0wXG4gICAgY29uc3QgY29vcmQwID0gdGhpcy50cmFuc2Zvcm1WZWN0b3IodGhpcy5waXhlbFVucHJvamVjdGlvbk1hdHJpeCwgW3gsIHkyLCAwLCAxXSk7XG4gICAgY29uc3QgY29vcmQxID0gdGhpcy50cmFuc2Zvcm1WZWN0b3IodGhpcy5waXhlbFVucHJvamVjdGlvbk1hdHJpeCwgW3gsIHkyLCAxLCAxXSk7XG5cbiAgICBjb25zdCB6MCA9IGNvb3JkMFsyXTtcbiAgICBjb25zdCB6MSA9IGNvb3JkMVsyXTtcblxuICAgIGNvbnN0IHQgPSB6MCA9PT0gejEgPyAwIDogKHRhcmdldFogLSB6MCkgLyAoejEgLSB6MCk7XG4gICAgY29uc3QgdiA9IHZlYzIubGVycChbXSwgY29vcmQwLCBjb29yZDEsIHQpO1xuXG4gICAgLy8gY29uc29sZS5lcnJvcihgdW5wcm9qZWN0aW5nIHRvIG5vbi1saW5lYXIgJHt2fTw9JHtbeCwgeTIsIHRhcmdldFpdfWApO1xuXG4gICAgY29uc3QgdlVucHJvamVjdGVkID0gdGhpcy51bnByb2plY3RGbGF0KHYpO1xuICAgIHJldHVybiB4eXoubGVuZ3RoID09PSAyID8gdlVucHJvamVjdGVkIDogW3ZVbnByb2plY3RlZFswXSwgdlVucHJvamVjdGVkWzFdLCAwXTtcbiAgfVxuXG4gIC8vIFRPRE8gLSByZXBsYWNlIHdpdGggbWF0aC5nbFxuICB0cmFuc2Zvcm1WZWN0b3IobWF0cml4LCB2ZWN0b3IpIHtcbiAgICBjb25zdCByZXN1bHQgPSB2ZWM0LnRyYW5zZm9ybU1hdDQoWzAsIDAsIDAsIDBdLCB2ZWN0b3IsIG1hdHJpeCk7XG4gICAgY29uc3Qgc2NhbGUgPSAxIC8gcmVzdWx0WzNdO1xuICAgIHZlYzQubXVsdGlwbHkocmVzdWx0LCByZXN1bHQsIFtzY2FsZSwgc2NhbGUsIHNjYWxlLCBzY2FsZV0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBOT05fTElORUFSIFBST0pFQ1RJT04gSE9PS1NcbiAgLy8gVXNlZCBmb3Igd2ViIG1lcmFjdG9yIHByb2plY3Rpb25cblxuICAvKipcbiAgICogUHJvamVjdCBbbG5nLGxhdF0gb24gc3BoZXJlIG9udG8gW3gseV0gb24gNTEyKjUxMiBNZXJjYXRvciBab29tIDAgdGlsZS5cbiAgICogUGVyZm9ybXMgdGhlIG5vbmxpbmVhciBwYXJ0IG9mIHRoZSB3ZWIgbWVyY2F0b3IgcHJvamVjdGlvbi5cbiAgICogUmVtYWluaW5nIHByb2plY3Rpb24gaXMgZG9uZSB3aXRoIDR4NCBtYXRyaWNlcyB3aGljaCBhbHNvIGhhbmRsZXNcbiAgICogcGVyc3BlY3RpdmUuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGxuZ0xhdCAtIFtsbmcsIGxhdF0gY29vcmRpbmF0ZXNcbiAgICogICBTcGVjaWZpZXMgYSBwb2ludCBvbiB0aGUgc3BoZXJlIHRvIHByb2plY3Qgb250byB0aGUgbWFwLlxuICAgKiBAcmV0dXJuIHtBcnJheX0gW3gseV0gY29vcmRpbmF0ZXMuXG4gICAqL1xuICBwcm9qZWN0RmxhdChbeCwgeV0sIHNjYWxlID0gdGhpcy5zY2FsZSkge1xuICAgIHJldHVybiB0aGlzLl9wcm9qZWN0RmxhdCguLi5hcmd1bWVudHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVucHJvamVjdCB3b3JsZCBwb2ludCBbeCx5XSBvbiBtYXAgb250byB7bGF0LCBsb259IG9uIHNwaGVyZVxuICAgKiBAcGFyYW0ge29iamVjdHxWZWN0b3J9IHh5IC0gb2JqZWN0IHdpdGgge3gseX0gbWVtYmVyc1xuICAgKiAgcmVwcmVzZW50aW5nIHBvaW50IG9uIHByb2plY3RlZCBtYXAgcGxhbmVcbiAgICogQHJldHVybiB7R2VvQ29vcmRpbmF0ZXN9IC0gb2JqZWN0IHdpdGgge2xhdCxsb259IG9mIHBvaW50IG9uIHNwaGVyZS5cbiAgICogICBIYXMgdG9BcnJheSBtZXRob2QgaWYgeW91IG5lZWQgYSBHZW9KU09OIEFycmF5LlxuICAgKiAgIFBlciBjYXJ0b2dyYXBoaWMgdHJhZGl0aW9uLCBsYXQgYW5kIGxvbiBhcmUgc3BlY2lmaWVkIGFzIGRlZ3JlZXMuXG4gICAqL1xuICB1bnByb2plY3RGbGF0KHh5eiwgc2NhbGUgPSB0aGlzLnNjYWxlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VucHJvamVjdEZsYXQoLi4uYXJndW1lbnRzKTtcbiAgfVxuXG4gIGdldE1hdHJpY2VzKHttb2RlbE1hdHJpeCA9IG51bGx9ID0ge30pIHtcbiAgICBsZXQgbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCA9IHRoaXMudmlld1Byb2plY3Rpb25NYXRyaXg7XG4gICAgbGV0IHBpeGVsUHJvamVjdGlvbk1hdHJpeCA9IHRoaXMucGl4ZWxQcm9qZWN0aW9uTWF0cml4O1xuICAgIGxldCBwaXhlbFVucHJvamVjdGlvbk1hdHJpeCA9IHRoaXMucGl4ZWxVbnByb2plY3Rpb25NYXRyaXg7XG5cbiAgICBpZiAobW9kZWxNYXRyaXgpIHtcbiAgICAgIG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXggPSBtYXQ0Lm11bHRpcGx5KFtdLCB0aGlzLnZpZXdQcm9qZWN0aW9uTWF0cml4LCBtb2RlbE1hdHJpeCk7XG4gICAgICBwaXhlbFByb2plY3Rpb25NYXRyaXggPSBtYXQ0Lm11bHRpcGx5KFtdLCB0aGlzLnBpeGVsUHJvamVjdGlvbk1hdHJpeCwgbW9kZWxNYXRyaXgpO1xuICAgICAgcGl4ZWxVbnByb2plY3Rpb25NYXRyaXggPSBtYXQ0LmludmVydChbXSwgcGl4ZWxQcm9qZWN0aW9uTWF0cml4KTtcbiAgICB9XG5cbiAgICBjb25zdCBtYXRyaWNlcyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCxcbiAgICAgIHZpZXdQcm9qZWN0aW9uTWF0cml4OiB0aGlzLnZpZXdQcm9qZWN0aW9uTWF0cml4LFxuICAgICAgdmlld01hdHJpeDogdGhpcy52aWV3TWF0cml4LFxuICAgICAgcHJvamVjdGlvbk1hdHJpeDogdGhpcy5wcm9qZWN0aW9uTWF0cml4LFxuXG4gICAgICAvLyBwcm9qZWN0L3VucHJvamVjdCBiZXR3ZWVuIHBpeGVscyBhbmQgd29ybGRcbiAgICAgIHBpeGVsUHJvamVjdGlvbk1hdHJpeCxcbiAgICAgIHBpeGVsVW5wcm9qZWN0aW9uTWF0cml4LFxuXG4gICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICBzY2FsZTogdGhpcy5zY2FsZVxuICAgIH0sXG5cbiAgICAgIC8vIFN1YmNsYXNzIGNhbiBhZGQgYWRkaXRpb25hbCBwYXJhbXNcbiAgICAgIC8vIFRPRE8gLSBGcmFnaWxlOiBiZXR0ZXIgdG8gbWFrZSBiYXNlIFZpZXdwb3J0IGNsYXNzIGF3YXJlIG9mIGFsbCBwYXJhbXNcbiAgICAgIHRoaXMuX2dldFBhcmFtcygpXG4gICAgKTtcblxuICAgIHJldHVybiBtYXRyaWNlcztcbiAgfVxuXG4gIC8vIElOVEVSTkFMIE1FVEhPRFNcblxuICAvLyBDYW4gYmUgc3ViY2xhc3NlZCB0byBhZGQgYWRkaXRpb25hbCBmaWVsZHMgdG8gYGdldE1hdHJpY2VzYFxuICBfZ2V0UGFyYW1zKCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxufVxuXG4vLyBIZWxwZXIsIGF2b2lkcyBsb3ctcHJlY2lzaW9uIDMyIGJpdCBtYXRyaWNlcyBmcm9tIGdsLW1hdHJpeCBtYXQ0LmNyZWF0ZSgpXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTWF0NCgpIHtcbiAgcmV0dXJuIFsxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxXTtcbn1cbiJdfQ==