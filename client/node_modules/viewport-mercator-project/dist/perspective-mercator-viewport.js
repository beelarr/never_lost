'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fitBounds = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.getFov = getFov;
exports.getClippingPlanes = getClippingPlanes;
exports.makeProjectionMatrixFromMercatorParams = makeProjectionMatrixFromMercatorParams;

var _viewport = require('./viewport');

var _viewport2 = _interopRequireDefault(_viewport);

var _glMatrix = require('gl-matrix');

var _autobind = require('./autobind');

var _autobind2 = _interopRequireDefault(_autobind);

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // View and Projection Matrix calculations for mapbox-js style
// map view properties


// CONSTANTS
var PI = Math.PI;
var PI_4 = PI / 4;
var DEGREES_TO_RADIANS = PI / 180;
var RADIANS_TO_DEGREES = 180 / PI;
var TILE_SIZE = 512;
var WORLD_SCALE = TILE_SIZE;

var DEFAULT_MAP_STATE = {
  latitude: 37,
  longitude: -122,
  zoom: 11,
  pitch: 0,
  bearing: 0,
  altitude: 1.5
};

var ERR_ARGUMENT = 'Illegal argument to WebMercatorViewport';

var WebMercatorViewport = function (_Viewport) {
  _inherits(WebMercatorViewport, _Viewport);

  /**
   * @classdesc
   * Creates view/projection matrices from mercator params
   * Note: The Viewport is immutable in the sense that it only has accessors.
   * A new viewport instance should be created if any parameters have changed.
   *
   * @class
   * @param {Object} opt - options
   * @param {Boolean} mercator=true - Whether to use mercator projection
   *
   * @param {Number} opt.width=1 - Width of "viewport" or window
   * @param {Number} opt.height=1 - Height of "viewport" or window
   * @param {Array} opt.center=[0, 0] - Center of viewport
   *   [longitude, latitude] or [x, y]
   * @param {Number} opt.scale=1 - Either use scale or zoom
   * @param {Number} opt.pitch=0 - Camera angle in degrees (0 is straight down)
   * @param {Number} opt.bearing=0 - Map rotation in degrees (0 means north is up)
   * @param {Number} opt.altitude= - Altitude of camera in screen units
   *
   * Web mercator projection short-hand parameters
   * @param {Number} opt.latitude - Center of viewport on map (alternative to opt.center)
   * @param {Number} opt.longitude - Center of viewport on map (alternative to opt.center)
   * @param {Number} opt.zoom - Scale = Math.pow(2,zoom) on map (alternative to opt.scale)
    * Notes:
   *  - Only one of center or [latitude, longitude] can be specified
   *  - [latitude, longitude] can only be specified when "mercator" is true
   *  - Altitude has a default value that matches assumptions in mapbox-gl
   *  - width and height are forced to 1 if supplied as 0, to avoid
   *    division by zero. This is intended to reduce the burden of apps to
   *    to check values before instantiating a Viewport.
   */
  /* eslint-disable complexity */
  function WebMercatorViewport() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        width = _ref.width,
        height = _ref.height,
        latitude = _ref.latitude,
        longitude = _ref.longitude,
        zoom = _ref.zoom,
        pitch = _ref.pitch,
        bearing = _ref.bearing,
        altitude = _ref.altitude,
        _ref$farZMultiplier = _ref.farZMultiplier,
        farZMultiplier = _ref$farZMultiplier === undefined ? 10 : _ref$farZMultiplier;

    _classCallCheck(this, WebMercatorViewport);

    // Viewport - support undefined arguments
    width = width !== undefined ? width : DEFAULT_MAP_STATE.width;
    height = height !== undefined ? height : DEFAULT_MAP_STATE.height;
    zoom = zoom !== undefined ? zoom : DEFAULT_MAP_STATE.zoom;
    latitude = latitude !== undefined ? latitude : DEFAULT_MAP_STATE.latitude;
    longitude = longitude !== undefined ? longitude : DEFAULT_MAP_STATE.longitude;
    bearing = bearing !== undefined ? bearing : DEFAULT_MAP_STATE.bearing;
    pitch = pitch !== undefined ? pitch : DEFAULT_MAP_STATE.pitch;
    altitude = altitude !== undefined ? altitude : DEFAULT_MAP_STATE.altitude;

    // Silently allow apps to send in 0,0 to facilitate isomorphic render etc
    width = width || 1;
    height = height || 1;

    var scale = Math.pow(2, zoom);
    // Altitude - prevent division by 0
    // TODO - just throw an Error instead?
    altitude = Math.max(0.75, altitude);

    var center = projectFlat([longitude, latitude], scale);

    var distanceScales = calculateDistanceScales({ latitude: latitude, longitude: longitude, scale: scale });

    var projectionMatrix = makeProjectionMatrixFromMercatorParams({
      width: width,
      height: height,
      pitch: pitch,
      bearing: bearing,
      altitude: altitude,
      farZMultiplier: farZMultiplier
    });

    var viewMatrix = makeViewMatrixFromMercatorParams({
      width: width,
      height: height,
      longitude: longitude,
      latitude: latitude,
      zoom: zoom,
      pitch: pitch,
      bearing: bearing,
      altitude: altitude,
      distanceScales: distanceScales,
      center: center
    });

    // Save parameters
    var _this = _possibleConstructorReturn(this, (WebMercatorViewport.__proto__ || Object.getPrototypeOf(WebMercatorViewport)).call(this, { width: width, height: height, viewMatrix: viewMatrix, projectionMatrix: projectionMatrix }));

    _this.latitude = latitude;
    _this.longitude = longitude;
    _this.zoom = zoom;
    _this.pitch = pitch;
    _this.bearing = bearing;
    _this.altitude = altitude;

    _this.scale = scale;
    _this.center = center;

    _this._distanceScales = distanceScales;

    (0, _autobind2.default)(_this);
    Object.freeze(_this);
    return _this;
  }
  /* eslint-enable complexity */

  /**
   * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.
   * Performs the nonlinear part of the web mercator projection.
   * Remaining projection is done with 4x4 matrices which also handles
   * perspective.
   *
   * @param {Array} lngLat - [lng, lat] coordinates
   *   Specifies a point on the sphere to project onto the map.
   * @return {Array} [x,y] coordinates.
   */


  _createClass(WebMercatorViewport, [{
    key: '_projectFlat',
    value: function _projectFlat(lngLat) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      return projectFlat(lngLat, scale);
    }

    /**
     * Unproject world point [x,y] on map onto {lat, lon} on sphere
     *
     * @param {object|Vector} xy - object with {x,y} members
     *  representing point on projected map plane
     * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.
     *   Has toArray method if you need a GeoJSON Array.
     *   Per cartographic tradition, lat and lon are specified as degrees.
     */

  }, {
    key: '_unprojectFlat',
    value: function _unprojectFlat(xy) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      return unprojectFlat(xy, scale);
    }

    /**
     * Get the map center that place a given [lng, lat] coordinate at screen
     * point [x, y]
     *
     * @param {Array} lngLat - [lng,lat] coordinates
     *   Specifies a point on the sphere.
     * @param {Array} pos - [x,y] coordinates
     *   Specifies a point on the screen.
     * @return {Array} [lng,lat] new map center.
     */

  }, {
    key: 'getLocationAtPoint',
    value: function getLocationAtPoint(_ref2) {
      var lngLat = _ref2.lngLat,
          pos = _ref2.pos;

      var fromLocation = this.projectFlat(this.unproject(pos));
      var toLocation = this.projectFlat(lngLat);

      var center = this.projectFlat([this.longitude, this.latitude]);

      var translate = _glMatrix.vec2.sub([], toLocation, fromLocation);
      var newCenter = _glMatrix.vec2.add([], center, translate);
      return this.unprojectFlat(newCenter);
    }

    /*
    getLngLatAtViewportPosition(lnglat, xy) {
      const c = this.locationCoordinate(lnglat);
      const coordAtPoint = this.pointCoordinate(xy);
      const coordCenter = this.pointCoordinate(this.centerPoint);
      const translate = coordAtPoint._sub(c);
      this.center = this.coordinateLocation(coordCenter._sub(translate));
    }
    */

  }, {
    key: 'getDistanceScales',
    value: function getDistanceScales() {
      return this._distanceScales;
    }

    /**
     * Converts a meter offset to a lnglat offset
     *
     * Note: Uses simple linear approximation around the viewport center
     * Error increases with size of offset (roughly 1% per 100km)
     *
     * @param {[Number,Number]|[Number,Number,Number]) xyz - array of meter deltas
     * @return {[Number,Number]|[Number,Number,Number]) - array of [lng,lat,z] deltas
     */

  }, {
    key: 'metersToLngLatDelta',
    value: function metersToLngLatDelta(xyz) {
      var _xyz = _slicedToArray(xyz, 3),
          x = _xyz[0],
          y = _xyz[1],
          _xyz$ = _xyz[2],
          z = _xyz$ === undefined ? 0 : _xyz$;

      (0, _assert2.default)(Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(z), ERR_ARGUMENT);
      var _distanceScales = this._distanceScales,
          pixelsPerMeter = _distanceScales.pixelsPerMeter,
          degreesPerPixel = _distanceScales.degreesPerPixel;

      var deltaLng = x * pixelsPerMeter[0] * degreesPerPixel[0];
      var deltaLat = y * pixelsPerMeter[1] * degreesPerPixel[1];
      return xyz.length === 2 ? [deltaLng, deltaLat] : [deltaLng, deltaLat, z];
    }

    /**
     * Converts a lnglat offset to a meter offset
     *
     * Note: Uses simple linear approximation around the viewport center
     * Error increases with size of offset (roughly 1% per 100km)
     *
     * @param {[Number,Number]|[Number,Number,Number]) deltaLngLatZ - array of [lng,lat,z] deltas
     * @return {[Number,Number]|[Number,Number,Number]) - array of meter deltas
     */

  }, {
    key: 'lngLatDeltaToMeters',
    value: function lngLatDeltaToMeters(deltaLngLatZ) {
      var _deltaLngLatZ = _slicedToArray(deltaLngLatZ, 3),
          deltaLng = _deltaLngLatZ[0],
          deltaLat = _deltaLngLatZ[1],
          _deltaLngLatZ$ = _deltaLngLatZ[2],
          deltaZ = _deltaLngLatZ$ === undefined ? 0 : _deltaLngLatZ$;

      (0, _assert2.default)(Number.isFinite(deltaLng) && Number.isFinite(deltaLat) && Number.isFinite(deltaZ), ERR_ARGUMENT);
      var _distanceScales2 = this._distanceScales,
          pixelsPerDegree = _distanceScales2.pixelsPerDegree,
          metersPerPixel = _distanceScales2.metersPerPixel;

      var deltaX = deltaLng * pixelsPerDegree[0] * metersPerPixel[0];
      var deltaY = deltaLat * pixelsPerDegree[1] * metersPerPixel[1];
      return deltaLngLatZ.length === 2 ? [deltaX, deltaY] : [deltaX, deltaY, deltaZ];
    }

    /**
     * Add a meter delta to a base lnglat coordinate, returning a new lnglat array
     *
     * Note: Uses simple linear approximation around the viewport center
     * Error increases with size of offset (roughly 1% per 100km)
     *
     * @param {[Number,Number]|[Number,Number,Number]) lngLatZ - base coordinate
     * @param {[Number,Number]|[Number,Number,Number]) xyz - array of meter deltas
     * @return {[Number,Number]|[Number,Number,Number]) array of [lng,lat,z] deltas
     */

  }, {
    key: 'addMetersToLngLat',
    value: function addMetersToLngLat(lngLatZ, xyz) {
      var _lngLatZ = _slicedToArray(lngLatZ, 3),
          lng = _lngLatZ[0],
          lat = _lngLatZ[1],
          _lngLatZ$ = _lngLatZ[2],
          Z = _lngLatZ$ === undefined ? 0 : _lngLatZ$;

      var _metersToLngLatDelta = this.metersToLngLatDelta(xyz),
          _metersToLngLatDelta2 = _slicedToArray(_metersToLngLatDelta, 3),
          deltaLng = _metersToLngLatDelta2[0],
          deltaLat = _metersToLngLatDelta2[1],
          _metersToLngLatDelta3 = _metersToLngLatDelta2[2],
          deltaZ = _metersToLngLatDelta3 === undefined ? 0 : _metersToLngLatDelta3;

      return lngLatZ.length === 2 ? [lng + deltaLng, lat + deltaLat] : [lng + deltaLng, lat + deltaLat, Z + deltaZ];
    }

    /**
     * Returns a new viewport that fit around the given rectangle.
     * Only supports non-perspective mode.
     * @param {Array} bounds - [[lon, lat], [lon, lat]]
     * @param {Number} [options.padding] - The amount of padding in pixels to add to the given bounds.
     * @param {Array} [options.offset] - The center of the given bounds relative to the map's center,
     *    [x, y] measured in pixels.
     * @returns {WebMercatorViewport}
     */

  }, {
    key: 'fitBounds',
    value: function fitBounds(bounds) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var width = this.width,
          height = this.height;

      var _fitBounds2 = _fitBounds(Object.assign({ width: width, height: height, bounds: bounds }, options)),
          longitude = _fitBounds2.longitude,
          latitude = _fitBounds2.latitude,
          zoom = _fitBounds2.zoom;

      return new WebMercatorViewport({ width: width, height: height, longitude: longitude, latitude: latitude, zoom: zoom });
    }

    // INTERNAL METHODS

  }, {
    key: '_getParams',
    value: function _getParams() {
      return this._distanceScales;
    }
  }]);

  return WebMercatorViewport;
}(_viewport2.default);

/**
 * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.
 * Performs the nonlinear part of the web mercator projection.
 * Remaining projection is done with 4x4 matrices which also handles
 * perspective.
 *
 * @param {Array} lngLat - [lng, lat] coordinates
 *   Specifies a point on the sphere to project onto the map.
 * @return {Array} [x,y] coordinates.
 */


exports.default = WebMercatorViewport;
function projectFlat(_ref3, scale) {
  var _ref4 = _slicedToArray(_ref3, 2),
      lng = _ref4[0],
      lat = _ref4[1];

  scale = scale * WORLD_SCALE;
  var lambda2 = lng * DEGREES_TO_RADIANS;
  var phi2 = lat * DEGREES_TO_RADIANS;
  var x = scale * (lambda2 + PI) / (2 * PI);
  var y = scale * (PI - Math.log(Math.tan(PI_4 + phi2 * 0.5))) / (2 * PI);
  return [x, y];
}

/**
 * Unproject world point [x,y] on map onto {lat, lon} on sphere
 *
 * @param {object|Vector} xy - object with {x,y} members
 *  representing point on projected map plane
 * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.
 *   Has toArray method if you need a GeoJSON Array.
 *   Per cartographic tradition, lat and lon are specified as degrees.
 */
function unprojectFlat(_ref5, scale) {
  var _ref6 = _slicedToArray(_ref5, 2),
      x = _ref6[0],
      y = _ref6[1];

  scale = scale * WORLD_SCALE;
  var lambda2 = x / scale * (2 * PI) - PI;
  var phi2 = 2 * (Math.atan(Math.exp(PI - y / scale * (2 * PI))) - PI_4);
  return [lambda2 * RADIANS_TO_DEGREES, phi2 * RADIANS_TO_DEGREES];
}

/**
 * Calculate distance scales in meters around current lat/lon, both for
 * degrees and pixels.
 * In mercator projection mode, the distance scales vary significantly
 * with latitude.
 */
function calculateDistanceScales(_ref7) {
  var latitude = _ref7.latitude,
      longitude = _ref7.longitude,
      scale = _ref7.scale;

  (0, _assert2.default)(!isNaN(latitude) && !isNaN(longitude) && !isNaN(scale), ERR_ARGUMENT);
  // Approximately 111km per degree at equator
  var METERS_PER_DEGREE = 111000;

  var latCosine = Math.cos(latitude * Math.PI / 180);

  var metersPerDegree = METERS_PER_DEGREE * latCosine;

  // Calculate number of pixels occupied by one degree longitude
  // around current lat/lon
  var pixelsPerDegreeX = _glMatrix.vec2.distance(projectFlat([longitude + 0.5, latitude], scale), projectFlat([longitude - 0.5, latitude], scale));
  // Calculate number of pixels occupied by one degree latitude
  // around current lat/lon
  var pixelsPerDegreeY = _glMatrix.vec2.distance(projectFlat([longitude, latitude + 0.5], scale), projectFlat([longitude, latitude - 0.5], scale));

  var pixelsPerMeterX = pixelsPerDegreeX / metersPerDegree;
  var pixelsPerMeterY = pixelsPerDegreeY / metersPerDegree;
  var pixelsPerMeterZ = (pixelsPerMeterX + pixelsPerMeterY) / 2;
  // const pixelsPerMeter = [pixelsPerMeterX, pixelsPerMeterY, pixelsPerMeterZ];

  var worldSize = TILE_SIZE * scale;
  var altPixelsPerMeter = worldSize / (4e7 * latCosine);
  var pixelsPerMeter = [altPixelsPerMeter, altPixelsPerMeter, altPixelsPerMeter];
  var metersPerPixel = [1 / altPixelsPerMeter, 1 / altPixelsPerMeter, 1 / pixelsPerMeterZ];

  var pixelsPerDegree = [pixelsPerDegreeX, pixelsPerDegreeY, pixelsPerMeterZ];
  var degreesPerPixel = [1 / pixelsPerDegreeX, 1 / pixelsPerDegreeY, 1 / pixelsPerMeterZ];

  // Main results, used for converting meters to latlng deltas and scaling offsets
  return {
    pixelsPerMeter: pixelsPerMeter,
    metersPerPixel: metersPerPixel,
    pixelsPerDegree: pixelsPerDegree,
    degreesPerPixel: degreesPerPixel
  };
}

// ATTRIBUTION:
// view and projection matrix creation is intentionally kept compatible with
// mapbox-gl's implementation to ensure that seamless interoperation
// with mapbox and react-map-gl. See: https://github.com/mapbox/mapbox-gl-js

// Variable fov (in radians)
function getFov(_ref8) {
  var height = _ref8.height,
      altitude = _ref8.altitude;

  return 2 * Math.atan(height / 2 / altitude);
}

function getClippingPlanes(_ref9) {
  var altitude = _ref9.altitude,
      pitch = _ref9.pitch;

  // Find the distance from the center point to the center top
  // in altitude units using law of sines.
  var pitchRadians = pitch * DEGREES_TO_RADIANS;
  var halfFov = Math.atan(0.5 / altitude);
  var topHalfSurfaceDistance = Math.sin(halfFov) * altitude / Math.sin(Math.PI / 2 - pitchRadians - halfFov);

  // Calculate z value of the farthest fragment that should be rendered.
  var farZ = Math.cos(Math.PI / 2 - pitchRadians) * topHalfSurfaceDistance + altitude;

  return { farZ: farZ, nearZ: 0.1 };
}

// PROJECTION MATRIX: PROJECTS FROM CAMERA (VIEW) SPACE TO CLIPSPACE
function makeProjectionMatrixFromMercatorParams(_ref10) {
  var width = _ref10.width,
      height = _ref10.height,
      pitch = _ref10.pitch,
      altitude = _ref10.altitude,
      _ref10$farZMultiplier = _ref10.farZMultiplier,
      farZMultiplier = _ref10$farZMultiplier === undefined ? 10 : _ref10$farZMultiplier;

  var _getClippingPlanes = getClippingPlanes({ altitude: altitude, pitch: pitch }),
      nearZ = _getClippingPlanes.nearZ,
      farZ = _getClippingPlanes.farZ;

  var fov = getFov({ height: height, altitude: altitude });

  var projectionMatrix = _glMatrix.mat4.perspective((0, _viewport.createMat4)(), fov, // fov in radians
  width / height, // aspect ratio
  nearZ, // near plane
  farZ * farZMultiplier // far plane
  );

  return projectionMatrix;
}

function makeViewMatrixFromMercatorParams(_ref11) {
  var width = _ref11.width,
      height = _ref11.height,
      longitude = _ref11.longitude,
      latitude = _ref11.latitude,
      zoom = _ref11.zoom,
      pitch = _ref11.pitch,
      bearing = _ref11.bearing,
      altitude = _ref11.altitude,
      center = _ref11.center;

  // VIEW MATRIX: PROJECTS FROM VIRTUAL PIXELS TO CAMERA SPACE
  // Note: As usual, matrix operation orders should be read in reverse
  // since vectors will be multiplied from the right during transformation
  var vm = (0, _viewport.createMat4)();

  // Move camera to altitude
  _glMatrix.mat4.translate(vm, vm, [0, 0, -altitude]);

  // After the rotateX, z values are in pixel units. Convert them to
  // altitude units. 1 altitude unit = the screen height.
  _glMatrix.mat4.scale(vm, vm, [1, -1, 1 / height]);

  // Rotate by bearing, and then by pitch (which tilts the view)
  _glMatrix.mat4.rotateX(vm, vm, pitch * DEGREES_TO_RADIANS);
  _glMatrix.mat4.rotateZ(vm, vm, -bearing * DEGREES_TO_RADIANS);
  // console.log(`VIEWPT Z ${pitch * DEGREES_TO_RADIANS} ${-bearing * DEGREES_TO_RADIANS} ${vm}`);
  _glMatrix.mat4.translate(vm, vm, [-center[0], -center[1], 0]);
  // console.log(`VIEWPT T ${pitch * DEGREES_TO_RADIANS} ${-bearing * DEGREES_TO_RADIANS} ${vm}`);
  return vm;
}

/**
 * Returns map settings {latitude, longitude, zoom}
 * that will contain the provided corners within the provided width.
 * Only supports non-perspective mode.
 * @param {Number} width - viewport width
 * @param {Number} height - viewport height
 * @param {Array} bounds - [[lon, lat], [lon, lat]]
 * @param {Number} [padding] - The amount of padding in pixels to add to the given bounds.
 * @param {Array} [offset] - The center of the given bounds relative to the map's center,
 *    [x, y] measured in pixels.
 * @returns {Object} - latitude, longitude and zoom
 */
function _fitBounds(_ref12) {
  var width = _ref12.width,
      height = _ref12.height,
      bounds = _ref12.bounds,
      _ref12$padding = _ref12.padding,
      padding = _ref12$padding === undefined ? 0 : _ref12$padding,
      _ref12$offset = _ref12.offset,
      offset = _ref12$offset === undefined ? [0, 0] : _ref12$offset;

  var _bounds = _slicedToArray(bounds, 2),
      _bounds$ = _slicedToArray(_bounds[0], 2),
      west = _bounds$[0],
      south = _bounds$[1],
      _bounds$2 = _slicedToArray(_bounds[1], 2),
      east = _bounds$2[0],
      north = _bounds$2[1];

  var viewport = new WebMercatorViewport({
    width: width,
    height: height,
    longitude: 0,
    latitude: 0,
    zoom: 0
  });

  var nw = viewport.project([west, north]);
  var se = viewport.project([east, south]);
  var size = [Math.abs(se[0] - nw[0]), Math.abs(se[1] - nw[1])];
  var center = [(se[0] + nw[0]) / 2, (se[1] + nw[1]) / 2];

  var scaleX = (width - padding * 2 - Math.abs(offset[0]) * 2) / size[0];
  var scaleY = (height - padding * 2 - Math.abs(offset[1]) * 2) / size[1];

  var centerLngLat = viewport.unproject(center);
  var zoom = viewport.zoom + Math.log2(Math.abs(Math.min(scaleX, scaleY)));

  return {
    longitude: centerLngLat[0],
    latitude: centerLngLat[1],
    zoom: zoom
  };
}
exports.fitBounds = _fitBounds;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9wZXJzcGVjdGl2ZS1tZXJjYXRvci12aWV3cG9ydC5qcyJdLCJuYW1lcyI6WyJnZXRGb3YiLCJnZXRDbGlwcGluZ1BsYW5lcyIsIm1ha2VQcm9qZWN0aW9uTWF0cml4RnJvbU1lcmNhdG9yUGFyYW1zIiwiUEkiLCJNYXRoIiwiUElfNCIsIkRFR1JFRVNfVE9fUkFESUFOUyIsIlJBRElBTlNfVE9fREVHUkVFUyIsIlRJTEVfU0laRSIsIldPUkxEX1NDQUxFIiwiREVGQVVMVF9NQVBfU1RBVEUiLCJsYXRpdHVkZSIsImxvbmdpdHVkZSIsInpvb20iLCJwaXRjaCIsImJlYXJpbmciLCJhbHRpdHVkZSIsIkVSUl9BUkdVTUVOVCIsIldlYk1lcmNhdG9yVmlld3BvcnQiLCJ3aWR0aCIsImhlaWdodCIsImZhclpNdWx0aXBsaWVyIiwidW5kZWZpbmVkIiwic2NhbGUiLCJwb3ciLCJtYXgiLCJjZW50ZXIiLCJwcm9qZWN0RmxhdCIsImRpc3RhbmNlU2NhbGVzIiwiY2FsY3VsYXRlRGlzdGFuY2VTY2FsZXMiLCJwcm9qZWN0aW9uTWF0cml4Iiwidmlld01hdHJpeCIsIm1ha2VWaWV3TWF0cml4RnJvbU1lcmNhdG9yUGFyYW1zIiwiX2Rpc3RhbmNlU2NhbGVzIiwiT2JqZWN0IiwiZnJlZXplIiwibG5nTGF0IiwieHkiLCJ1bnByb2plY3RGbGF0IiwicG9zIiwiZnJvbUxvY2F0aW9uIiwidW5wcm9qZWN0IiwidG9Mb2NhdGlvbiIsInRyYW5zbGF0ZSIsInN1YiIsIm5ld0NlbnRlciIsImFkZCIsInh5eiIsIngiLCJ5IiwieiIsIk51bWJlciIsImlzRmluaXRlIiwicGl4ZWxzUGVyTWV0ZXIiLCJkZWdyZWVzUGVyUGl4ZWwiLCJkZWx0YUxuZyIsImRlbHRhTGF0IiwibGVuZ3RoIiwiZGVsdGFMbmdMYXRaIiwiZGVsdGFaIiwicGl4ZWxzUGVyRGVncmVlIiwibWV0ZXJzUGVyUGl4ZWwiLCJkZWx0YVgiLCJkZWx0YVkiLCJsbmdMYXRaIiwibG5nIiwibGF0IiwiWiIsIm1ldGVyc1RvTG5nTGF0RGVsdGEiLCJib3VuZHMiLCJvcHRpb25zIiwiZml0Qm91bmRzIiwiYXNzaWduIiwibGFtYmRhMiIsInBoaTIiLCJsb2ciLCJ0YW4iLCJhdGFuIiwiZXhwIiwiaXNOYU4iLCJNRVRFUlNfUEVSX0RFR1JFRSIsImxhdENvc2luZSIsImNvcyIsIm1ldGVyc1BlckRlZ3JlZSIsInBpeGVsc1BlckRlZ3JlZVgiLCJkaXN0YW5jZSIsInBpeGVsc1BlckRlZ3JlZVkiLCJwaXhlbHNQZXJNZXRlclgiLCJwaXhlbHNQZXJNZXRlclkiLCJwaXhlbHNQZXJNZXRlcloiLCJ3b3JsZFNpemUiLCJhbHRQaXhlbHNQZXJNZXRlciIsInBpdGNoUmFkaWFucyIsImhhbGZGb3YiLCJ0b3BIYWxmU3VyZmFjZURpc3RhbmNlIiwic2luIiwiZmFyWiIsIm5lYXJaIiwiZm92IiwicGVyc3BlY3RpdmUiLCJ2bSIsInJvdGF0ZVgiLCJyb3RhdGVaIiwicGFkZGluZyIsIm9mZnNldCIsIndlc3QiLCJzb3V0aCIsImVhc3QiLCJub3J0aCIsInZpZXdwb3J0IiwibnciLCJwcm9qZWN0Iiwic2UiLCJzaXplIiwiYWJzIiwic2NhbGVYIiwic2NhbGVZIiwiY2VudGVyTG5nTGF0IiwibG9nMiIsIm1pbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7UUErV2dCQSxNLEdBQUFBLE07UUFJQUMsaUIsR0FBQUEsaUI7UUFlQUMsc0MsR0FBQUEsc0M7O0FBaFloQjs7OztBQUNBOztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7K2VBTEE7QUFDQTs7O0FBTUE7QUFDQSxJQUFNQyxLQUFLQyxLQUFLRCxFQUFoQjtBQUNBLElBQU1FLE9BQU9GLEtBQUssQ0FBbEI7QUFDQSxJQUFNRyxxQkFBcUJILEtBQUssR0FBaEM7QUFDQSxJQUFNSSxxQkFBcUIsTUFBTUosRUFBakM7QUFDQSxJQUFNSyxZQUFZLEdBQWxCO0FBQ0EsSUFBTUMsY0FBY0QsU0FBcEI7O0FBRUEsSUFBTUUsb0JBQW9CO0FBQ3hCQyxZQUFVLEVBRGM7QUFFeEJD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LFNBQVNoRyxJQUFULEdBQWdCVCxLQUFLa0gsSUFBTCxDQUFVbEgsS0FBSzhHLEdBQUwsQ0FBUzlHLEtBQUttSCxHQUFMLENBQVNKLE1BQVQsRUFBaUJDLE1BQWpCLENBQVQsQ0FBVixDQUE3Qjs7QUFFQSxTQUFPO0FBQ0x4RyxlQUFXeUcsYUFBYSxDQUFiLENBRE47QUFFTDFHLGNBQVUwRyxhQUFhLENBQWIsQ0FGTDtBQUdMeEc7QUFISyxHQUFQO0FBS0QiLCJmaWxlIjoicGVyc3BlY3RpdmUtbWVyY2F0b3Itdmlld3BvcnQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBWaWV3IGFuZCBQcm9qZWN0aW9uIE1hdHJpeCBjYWxjdWxhdGlvbnMgZm9yIG1hcGJveC1qcyBzdHlsZVxuLy8gbWFwIHZpZXcgcHJvcGVydGllc1xuaW1wb3J0IFZpZXdwb3J0LCB7Y3JlYXRlTWF0NH0gZnJvbSAnLi92aWV3cG9ydCc7XG5pbXBvcnQge21hdDQsIHZlYzJ9IGZyb20gJ2dsLW1hdHJpeCc7XG5pbXBvcnQgYXV0b2JpbmQgZnJvbSAnLi9hdXRvYmluZCc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5cbi8vIENPTlNUQU5UU1xuY29uc3QgUEkgPSBNYXRoLlBJO1xuY29uc3QgUElfNCA9IFBJIC8gNDtcbmNvbnN0IERFR1JFRVNfVE9fUkFESUFOUyA9IFBJIC8gMTgwO1xuY29uc3QgUkFESUFOU19UT19ERUdSRUVTID0gMTgwIC8gUEk7XG5jb25zdCBUSUxFX1NJWkUgPSA1MTI7XG5jb25zdCBXT1JMRF9TQ0FMRSA9IFRJTEVfU0laRTtcblxuY29uc3QgREVGQVVMVF9NQVBfU1RBVEUgPSB7XG4gIGxhdGl0dWRlOiAzNyxcbiAgbG9uZ2l0dWRlOiAtMTIyLFxuICB6b29tOiAxMSxcbiAgcGl0Y2g6IDAsXG4gIGJlYXJpbmc6IDAsXG4gIGFsdGl0dWRlOiAxLjVcbn07XG5cbmNvbnN0IEVSUl9BUkdVTUVOVCA9ICdJbGxlZ2FsIGFyZ3VtZW50IHRvIFdlYk1lcmNhdG9yVmlld3BvcnQnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXZWJNZXJjYXRvclZpZXdwb3J0IGV4dGVuZHMgVmlld3BvcnQge1xuICAvKipcbiAgICogQGNsYXNzZGVzY1xuICAgKiBDcmVhdGVzIHZpZXcvcHJvamVjdGlvbiBtYXRyaWNlcyBmcm9tIG1lcmNhdG9yIHBhcmFtc1xuICAgKiBOb3RlOiBUaGUgVmlld3BvcnQgaXMgaW1tdXRhYmxlIGluIHRoZSBzZW5zZSB0aGF0IGl0IG9ubHkgaGFzIGFjY2Vzc29ycy5cbiAgICogQSBuZXcgdmlld3BvcnQgaW5zdGFuY2Ugc2hvdWxkIGJlIGNyZWF0ZWQgaWYgYW55IHBhcmFtZXRlcnMgaGF2ZSBjaGFuZ2VkLlxuICAgKlxuICAgKiBAY2xhc3NcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdCAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtCb29sZWFufSBtZXJjYXRvcj10cnVlIC0gV2hldGhlciB0byB1c2UgbWVyY2F0b3IgcHJvamVjdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LndpZHRoPTEgLSBXaWR0aCBvZiBcInZpZXdwb3J0XCIgb3Igd2luZG93XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQuaGVpZ2h0PTEgLSBIZWlnaHQgb2YgXCJ2aWV3cG9ydFwiIG9yIHdpbmRvd1xuICAgKiBAcGFyYW0ge0FycmF5fSBvcHQuY2VudGVyPVswLCAwXSAtIENlbnRlciBvZiB2aWV3cG9ydFxuICAgKiAgIFtsb25naXR1ZGUsIGxhdGl0dWRlXSBvciBbeCwgeV1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC5zY2FsZT0xIC0gRWl0aGVyIHVzZSBzY2FsZSBvciB6b29tXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQucGl0Y2g9MCAtIENhbWVyYSBhbmdsZSBpbiBkZWdyZWVzICgwIGlzIHN0cmFpZ2h0IGRvd24pXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQuYmVhcmluZz0wIC0gTWFwIHJvdGF0aW9uIGluIGRlZ3JlZXMgKDAgbWVhbnMgbm9ydGggaXMgdXApXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQuYWx0aXR1ZGU9IC0gQWx0aXR1ZGUgb2YgY2FtZXJhIGluIHNjcmVlbiB1bml0c1xuICAgKlxuICAgKiBXZWIgbWVyY2F0b3IgcHJvamVjdGlvbiBzaG9ydC1oYW5kIHBhcmFtZXRlcnNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC5sYXRpdHVkZSAtIENlbnRlciBvZiB2aWV3cG9ydCBvbiBtYXAgKGFsdGVybmF0aXZlIHRvIG9wdC5jZW50ZXIpXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQubG9uZ2l0dWRlIC0gQ2VudGVyIG9mIHZpZXdwb3J0IG9uIG1hcCAoYWx0ZXJuYXRpdmUgdG8gb3B0LmNlbnRlcilcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC56b29tIC0gU2NhbGUgPSBNYXRoLnBvdygyLHpvb20pIG9uIG1hcCAoYWx0ZXJuYXRpdmUgdG8gb3B0LnNjYWxlKVxuXG4gICAqIE5vdGVzOlxuICAgKiAgLSBPbmx5IG9uZSBvZiBjZW50ZXIgb3IgW2xhdGl0dWRlLCBsb25naXR1ZGVdIGNhbiBiZSBzcGVjaWZpZWRcbiAgICogIC0gW2xhdGl0dWRlLCBsb25naXR1ZGVdIGNhbiBvbmx5IGJlIHNwZWNpZmllZCB3aGVuIFwibWVyY2F0b3JcIiBpcyB0cnVlXG4gICAqICAtIEFsdGl0dWRlIGhhcyBhIGRlZmF1bHQgdmFsdWUgdGhhdCBtYXRjaGVzIGFzc3VtcHRpb25zIGluIG1hcGJveC1nbFxuICAgKiAgLSB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBmb3JjZWQgdG8gMSBpZiBzdXBwbGllZCBhcyAwLCB0byBhdm9pZFxuICAgKiAgICBkaXZpc2lvbiBieSB6ZXJvLiBUaGlzIGlzIGludGVuZGVkIHRvIHJlZHVjZSB0aGUgYnVyZGVuIG9mIGFwcHMgdG9cbiAgICogICAgdG8gY2hlY2sgdmFsdWVzIGJlZm9yZSBpbnN0YW50aWF0aW5nIGEgVmlld3BvcnQuXG4gICAqL1xuICAvKiBlc2xpbnQtZGlzYWJsZSBjb21wbGV4aXR5ICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICAvLyBNYXAgc3RhdGVcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgbGF0aXR1ZGUsXG4gICAgbG9uZ2l0dWRlLFxuICAgIHpvb20sXG4gICAgcGl0Y2gsXG4gICAgYmVhcmluZyxcbiAgICBhbHRpdHVkZSxcbiAgICBmYXJaTXVsdGlwbGllciA9IDEwXG4gIH0gPSB7fSkge1xuICAgIC8vIFZpZXdwb3J0IC0gc3VwcG9ydCB1bmRlZmluZWQgYXJndW1lbnRzXG4gICAgd2lkdGggPSB3aWR0aCAhPT0gdW5kZWZpbmVkID8gd2lkdGggOiBERUZBVUxUX01BUF9TVEFURS53aWR0aDtcbiAgICBoZWlnaHQgPSBoZWlnaHQgIT09IHVuZGVmaW5lZCA/IGhlaWdodCA6IERFRkFVTFRfTUFQX1NUQVRFLmhlaWdodDtcbiAgICB6b29tID0gem9vbSAhPT0gdW5kZWZpbmVkID8gem9vbSA6IERFRkFVTFRfTUFQX1NUQVRFLnpvb207XG4gICAgbGF0aXR1ZGUgPSBsYXRpdHVkZSAhPT0gdW5kZWZpbmVkID8gbGF0aXR1ZGUgOiBERUZBVUxUX01BUF9TVEFURS5sYXRpdHVkZTtcbiAgICBsb25naXR1ZGUgPSBsb25naXR1ZGUgIT09IHVuZGVmaW5lZCA/IGxvbmdpdHVkZSA6IERFRkFVTFRfTUFQX1NUQVRFLmxvbmdpdHVkZTtcbiAgICBiZWFyaW5nID0gYmVhcmluZyAhPT0gdW5kZWZpbmVkID8gYmVhcmluZyA6IERFRkFVTFRfTUFQX1NUQVRFLmJlYXJpbmc7XG4gICAgcGl0Y2ggPSBwaXRjaCAhPT0gdW5kZWZpbmVkID8gcGl0Y2ggOiBERUZBVUxUX01BUF9TVEFURS5waXRjaDtcbiAgICBhbHRpdHVkZSA9IGFsdGl0dWRlICE9PSB1bmRlZmluZWQgPyBhbHRpdHVkZSA6IERFRkFVTFRfTUFQX1NUQVRFLmFsdGl0dWRlO1xuXG4gICAgLy8gU2lsZW50bHkgYWxsb3cgYXBwcyB0byBzZW5kIGluIDAsMCB0byBmYWNpbGl0YXRlIGlzb21vcnBoaWMgcmVuZGVyIGV0Y1xuICAgIHdpZHRoID0gd2lkdGggfHwgMTtcbiAgICBoZWlnaHQgPSBoZWlnaHQgfHwgMTtcblxuICAgIGNvbnN0IHNjYWxlID0gTWF0aC5wb3coMiwgem9vbSk7XG4gICAgLy8gQWx0aXR1ZGUgLSBwcmV2ZW50IGRpdmlzaW9uIGJ5IDBcbiAgICAvLyBUT0RPIC0ganVzdCB0aHJvdyBhbiBFcnJvciBpbnN0ZWFkP1xuICAgIGFsdGl0dWRlID0gTWF0aC5tYXgoMC43NSwgYWx0aXR1ZGUpO1xuXG4gICAgY29uc3QgY2VudGVyID0gcHJvamVjdEZsYXQoW2xvbmdpdHVkZSwgbGF0aXR1ZGVdLCBzY2FsZSk7XG5cbiAgICBjb25zdCBkaXN0YW5jZVNjYWxlcyA9IGNhbGN1bGF0ZURpc3RhbmNlU2NhbGVzKHtsYXRpdHVkZSwgbG9uZ2l0dWRlLCBzY2FsZX0pO1xuXG4gICAgY29uc3QgcHJvamVjdGlvbk1hdHJpeCA9IG1ha2VQcm9qZWN0aW9uTWF0cml4RnJvbU1lcmNhdG9yUGFyYW1zKHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgcGl0Y2gsXG4gICAgICBiZWFyaW5nLFxuICAgICAgYWx0aXR1ZGUsXG4gICAgICBmYXJaTXVsdGlwbGllclxuICAgIH0pO1xuXG4gICAgY29uc3Qgdmlld01hdHJpeCA9IG1ha2VWaWV3TWF0cml4RnJvbU1lcmNhdG9yUGFyYW1zKHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgbG9uZ2l0dWRlLFxuICAgICAgbGF0aXR1ZGUsXG4gICAgICB6b29tLFxuICAgICAgcGl0Y2gsXG4gICAgICBiZWFyaW5nLFxuICAgICAgYWx0aXR1ZGUsXG4gICAgICBkaXN0YW5jZVNjYWxlcyxcbiAgICAgIGNlbnRlclxuICAgIH0pO1xuXG4gICAgc3VwZXIoe3dpZHRoLCBoZWlnaHQsIHZpZXdNYXRyaXgsIHByb2plY3Rpb25NYXRyaXh9KTtcblxuICAgIC8vIFNhdmUgcGFyYW1ldGVyc1xuICAgIHRoaXMubGF0aXR1ZGUgPSBsYXRpdHVkZTtcbiAgICB0aGlzLmxvbmdpdHVkZSA9IGxvbmdpdHVkZTtcbiAgICB0aGlzLnpvb20gPSB6b29tO1xuICAgIHRoaXMucGl0Y2ggPSBwaXRjaDtcbiAgICB0aGlzLmJlYXJpbmcgPSBiZWFyaW5nO1xuICAgIHRoaXMuYWx0aXR1ZGUgPSBhbHRpdHVkZTtcblxuICAgIHRoaXMuc2NhbGUgPSBzY2FsZTtcbiAgICB0aGlzLmNlbnRlciA9IGNlbnRlcjtcblxuICAgIHRoaXMuX2Rpc3RhbmNlU2NhbGVzID0gZGlzdGFuY2VTY2FsZXM7XG5cbiAgICBhdXRvYmluZCh0aGlzKTtcbiAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgY29tcGxleGl0eSAqL1xuXG4gIC8qKlxuICAgKiBQcm9qZWN0IFtsbmcsbGF0XSBvbiBzcGhlcmUgb250byBbeCx5XSBvbiA1MTIqNTEyIE1lcmNhdG9yIFpvb20gMCB0aWxlLlxuICAgKiBQZXJmb3JtcyB0aGUgbm9ubGluZWFyIHBhcnQgb2YgdGhlIHdlYiBtZXJjYXRvciBwcm9qZWN0aW9uLlxuICAgKiBSZW1haW5pbmcgcHJvamVjdGlvbiBpcyBkb25lIHdpdGggNHg0IG1hdHJpY2VzIHdoaWNoIGFsc28gaGFuZGxlc1xuICAgKiBwZXJzcGVjdGl2ZS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gbG5nTGF0IC0gW2xuZywgbGF0XSBjb29yZGluYXRlc1xuICAgKiAgIFNwZWNpZmllcyBhIHBvaW50IG9uIHRoZSBzcGhlcmUgdG8gcHJvamVjdCBvbnRvIHRoZSBtYXAuXG4gICAqIEByZXR1cm4ge0FycmF5fSBbeCx5XSBjb29yZGluYXRlcy5cbiAgICovXG4gIF9wcm9qZWN0RmxhdChsbmdMYXQsIHNjYWxlID0gdGhpcy5zY2FsZSkge1xuICAgIHJldHVybiBwcm9qZWN0RmxhdChsbmdMYXQsIHNjYWxlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnByb2plY3Qgd29ybGQgcG9pbnQgW3gseV0gb24gbWFwIG9udG8ge2xhdCwgbG9ufSBvbiBzcGhlcmVcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R8VmVjdG9yfSB4eSAtIG9iamVjdCB3aXRoIHt4LHl9IG1lbWJlcnNcbiAgICogIHJlcHJlc2VudGluZyBwb2ludCBvbiBwcm9qZWN0ZWQgbWFwIHBsYW5lXG4gICAqIEByZXR1cm4ge0dlb0Nvb3JkaW5hdGVzfSAtIG9iamVjdCB3aXRoIHtsYXQsbG9ufSBvZiBwb2ludCBvbiBzcGhlcmUuXG4gICAqICAgSGFzIHRvQXJyYXkgbWV0aG9kIGlmIHlvdSBuZWVkIGEgR2VvSlNPTiBBcnJheS5cbiAgICogICBQZXIgY2FydG9ncmFwaGljIHRyYWRpdGlvbiwgbGF0IGFuZCBsb24gYXJlIHNwZWNpZmllZCBhcyBkZWdyZWVzLlxuICAgKi9cbiAgX3VucHJvamVjdEZsYXQoeHksIHNjYWxlID0gdGhpcy5zY2FsZSkge1xuICAgIHJldHVybiB1bnByb2plY3RGbGF0KHh5LCBzY2FsZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtYXAgY2VudGVyIHRoYXQgcGxhY2UgYSBnaXZlbiBbbG5nLCBsYXRdIGNvb3JkaW5hdGUgYXQgc2NyZWVuXG4gICAqIHBvaW50IFt4LCB5XVxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBsbmdMYXQgLSBbbG5nLGxhdF0gY29vcmRpbmF0ZXNcbiAgICogICBTcGVjaWZpZXMgYSBwb2ludCBvbiB0aGUgc3BoZXJlLlxuICAgKiBAcGFyYW0ge0FycmF5fSBwb3MgLSBbeCx5XSBjb29yZGluYXRlc1xuICAgKiAgIFNwZWNpZmllcyBhIHBvaW50IG9uIHRoZSBzY3JlZW4uXG4gICAqIEByZXR1cm4ge0FycmF5fSBbbG5nLGxhdF0gbmV3IG1hcCBjZW50ZXIuXG4gICAqL1xuICBnZXRMb2NhdGlvbkF0UG9pbnQoe2xuZ0xhdCwgcG9zfSkge1xuICAgIGNvbnN0IGZyb21Mb2NhdGlvbiA9IHRoaXMucHJvamVjdEZsYXQodGhpcy51bnByb2plY3QocG9zKSk7XG4gICAgY29uc3QgdG9Mb2NhdGlvbiA9IHRoaXMucHJvamVjdEZsYXQobG5nTGF0KTtcblxuICAgIGNvbnN0IGNlbnRlciA9IHRoaXMucHJvamVjdEZsYXQoW3RoaXMubG9uZ2l0dWRlLCB0aGlzLmxhdGl0dWRlXSk7XG5cbiAgICBjb25zdCB0cmFuc2xhdGUgPSB2ZWMyLnN1YihbXSwgdG9Mb2NhdGlvbiwgZnJvbUxvY2F0aW9uKTtcbiAgICBjb25zdCBuZXdDZW50ZXIgPSB2ZWMyLmFkZChbXSwgY2VudGVyLCB0cmFuc2xhdGUpO1xuICAgIHJldHVybiB0aGlzLnVucHJvamVjdEZsYXQobmV3Q2VudGVyKTtcbiAgfVxuXG4gIC8qXG4gIGdldExuZ0xhdEF0Vmlld3BvcnRQb3NpdGlvbihsbmdsYXQsIHh5KSB7XG4gICAgY29uc3QgYyA9IHRoaXMubG9jYXRpb25Db29yZGluYXRlKGxuZ2xhdCk7XG4gICAgY29uc3QgY29vcmRBdFBvaW50ID0gdGhpcy5wb2ludENvb3JkaW5hdGUoeHkpO1xuICAgIGNvbnN0IGNvb3JkQ2VudGVyID0gdGhpcy5wb2ludENvb3JkaW5hdGUodGhpcy5jZW50ZXJQb2ludCk7XG4gICAgY29uc3QgdHJhbnNsYXRlID0gY29vcmRBdFBvaW50Ll9zdWIoYyk7XG4gICAgdGhpcy5jZW50ZXIgPSB0aGlzLmNvb3JkaW5hdGVMb2NhdGlvbihjb29yZENlbnRlci5fc3ViKHRyYW5zbGF0ZSkpO1xuICB9XG4gICovXG5cbiAgZ2V0RGlzdGFuY2VTY2FsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Rpc3RhbmNlU2NhbGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgbWV0ZXIgb2Zmc2V0IHRvIGEgbG5nbGF0IG9mZnNldFxuICAgKlxuICAgKiBOb3RlOiBVc2VzIHNpbXBsZSBsaW5lYXIgYXBwcm94aW1hdGlvbiBhcm91bmQgdGhlIHZpZXdwb3J0IGNlbnRlclxuICAgKiBFcnJvciBpbmNyZWFzZXMgd2l0aCBzaXplIG9mIG9mZnNldCAocm91Z2hseSAxJSBwZXIgMTAwa20pXG4gICAqXG4gICAqIEBwYXJhbSB7W051bWJlcixOdW1iZXJdfFtOdW1iZXIsTnVtYmVyLE51bWJlcl0pIHh5eiAtIGFycmF5IG9mIG1ldGVyIGRlbHRhc1xuICAgKiBAcmV0dXJuIHtbTnVtYmVyLE51bWJlcl18W051bWJlcixOdW1iZXIsTnVtYmVyXSkgLSBhcnJheSBvZiBbbG5nLGxhdCx6XSBkZWx0YXNcbiAgICovXG4gIG1ldGVyc1RvTG5nTGF0RGVsdGEoeHl6KSB7XG4gICAgY29uc3QgW3gsIHksIHogPSAwXSA9IHh5ejtcbiAgICBhc3NlcnQoTnVtYmVyLmlzRmluaXRlKHgpICYmIE51bWJlci5pc0Zpbml0ZSh5KSAmJiBOdW1iZXIuaXNGaW5pdGUoeiksIEVSUl9BUkdVTUVOVCk7XG4gICAgY29uc3Qge3BpeGVsc1Blck1ldGVyLCBkZWdyZWVzUGVyUGl4ZWx9ID0gdGhpcy5fZGlzdGFuY2VTY2FsZXM7XG4gICAgY29uc3QgZGVsdGFMbmcgPSB4ICogcGl4ZWxzUGVyTWV0ZXJbMF0gKiBkZWdyZWVzUGVyUGl4ZWxbMF07XG4gICAgY29uc3QgZGVsdGFMYXQgPSB5ICogcGl4ZWxzUGVyTWV0ZXJbMV0gKiBkZWdyZWVzUGVyUGl4ZWxbMV07XG4gICAgcmV0dXJuIHh5ei5sZW5ndGggPT09IDIgPyBbZGVsdGFMbmcsIGRlbHRhTGF0XSA6IFtkZWx0YUxuZywgZGVsdGFMYXQsIHpdO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgbG5nbGF0IG9mZnNldCB0byBhIG1ldGVyIG9mZnNldFxuICAgKlxuICAgKiBOb3RlOiBVc2VzIHNpbXBsZSBsaW5lYXIgYXBwcm94aW1hdGlvbiBhcm91bmQgdGhlIHZpZXdwb3J0IGNlbnRlclxuICAgKiBFcnJvciBpbmNyZWFzZXMgd2l0aCBzaXplIG9mIG9mZnNldCAocm91Z2hseSAxJSBwZXIgMTAwa20pXG4gICAqXG4gICAqIEBwYXJhbSB7W051bWJlcixOdW1iZXJdfFtOdW1iZXIsTnVtYmVyLE51bWJlcl0pIGRlbHRhTG5nTGF0WiAtIGFycmF5IG9mIFtsbmcsbGF0LHpdIGRlbHRhc1xuICAgKiBAcmV0dXJuIHtbTnVtYmVyLE51bWJlcl18W051bWJlcixOdW1iZXIsTnVtYmVyXSkgLSBhcnJheSBvZiBtZXRlciBkZWx0YXNcbiAgICovXG4gIGxuZ0xhdERlbHRhVG9NZXRlcnMoZGVsdGFMbmdMYXRaKSB7XG4gICAgY29uc3QgW2RlbHRhTG5nLCBkZWx0YUxhdCwgZGVsdGFaID0gMF0gPSBkZWx0YUxuZ0xhdFo7XG4gICAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZShkZWx0YUxuZykgJiYgTnVtYmVyLmlzRmluaXRlKGRlbHRhTGF0KSAmJiBOdW1iZXIuaXNGaW5pdGUoZGVsdGFaKSxcbiAgICAgIEVSUl9BUkdVTUVOVCk7XG4gICAgY29uc3Qge3BpeGVsc1BlckRlZ3JlZSwgbWV0ZXJzUGVyUGl4ZWx9ID0gdGhpcy5fZGlzdGFuY2VTY2FsZXM7XG4gICAgY29uc3QgZGVsdGFYID0gZGVsdGFMbmcgKiBwaXhlbHNQZXJEZWdyZWVbMF0gKiBtZXRlcnNQZXJQaXhlbFswXTtcbiAgICBjb25zdCBkZWx0YVkgPSBkZWx0YUxhdCAqIHBpeGVsc1BlckRlZ3JlZVsxXSAqIG1ldGVyc1BlclBpeGVsWzFdO1xuICAgIHJldHVybiBkZWx0YUxuZ0xhdFoubGVuZ3RoID09PSAyID8gW2RlbHRhWCwgZGVsdGFZXSA6IFtkZWx0YVgsIGRlbHRhWSwgZGVsdGFaXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBtZXRlciBkZWx0YSB0byBhIGJhc2UgbG5nbGF0IGNvb3JkaW5hdGUsIHJldHVybmluZyBhIG5ldyBsbmdsYXQgYXJyYXlcbiAgICpcbiAgICogTm90ZTogVXNlcyBzaW1wbGUgbGluZWFyIGFwcHJveGltYXRpb24gYXJvdW5kIHRoZSB2aWV3cG9ydCBjZW50ZXJcbiAgICogRXJyb3IgaW5jcmVhc2VzIHdpdGggc2l6ZSBvZiBvZmZzZXQgKHJvdWdobHkgMSUgcGVyIDEwMGttKVxuICAgKlxuICAgKiBAcGFyYW0ge1tOdW1iZXIsTnVtYmVyXXxbTnVtYmVyLE51bWJlcixOdW1iZXJdKSBsbmdMYXRaIC0gYmFzZSBjb29yZGluYXRlXG4gICAqIEBwYXJhbSB7W051bWJlcixOdW1iZXJdfFtOdW1iZXIsTnVtYmVyLE51bWJlcl0pIHh5eiAtIGFycmF5IG9mIG1ldGVyIGRlbHRhc1xuICAgKiBAcmV0dXJuIHtbTnVtYmVyLE51bWJlcl18W051bWJlcixOdW1iZXIsTnVtYmVyXSkgYXJyYXkgb2YgW2xuZyxsYXQsel0gZGVsdGFzXG4gICAqL1xuICBhZGRNZXRlcnNUb0xuZ0xhdChsbmdMYXRaLCB4eXopIHtcbiAgICBjb25zdCBbbG5nLCBsYXQsIFogPSAwXSA9IGxuZ0xhdFo7XG4gICAgY29uc3QgW2RlbHRhTG5nLCBkZWx0YUxhdCwgZGVsdGFaID0gMF0gPSB0aGlzLm1ldGVyc1RvTG5nTGF0RGVsdGEoeHl6KTtcbiAgICByZXR1cm4gbG5nTGF0Wi5sZW5ndGggPT09IDIgP1xuICAgICAgW2xuZyArIGRlbHRhTG5nLCBsYXQgKyBkZWx0YUxhdF0gOlxuICAgICAgW2xuZyArIGRlbHRhTG5nLCBsYXQgKyBkZWx0YUxhdCwgWiArIGRlbHRhWl07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyB2aWV3cG9ydCB0aGF0IGZpdCBhcm91bmQgdGhlIGdpdmVuIHJlY3RhbmdsZS5cbiAgICogT25seSBzdXBwb3J0cyBub24tcGVyc3BlY3RpdmUgbW9kZS5cbiAgICogQHBhcmFtIHtBcnJheX0gYm91bmRzIC0gW1tsb24sIGxhdF0sIFtsb24sIGxhdF1dXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wYWRkaW5nXSAtIFRoZSBhbW91bnQgb2YgcGFkZGluZyBpbiBwaXhlbHMgdG8gYWRkIHRvIHRoZSBnaXZlbiBib3VuZHMuXG4gICAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLm9mZnNldF0gLSBUaGUgY2VudGVyIG9mIHRoZSBnaXZlbiBib3VuZHMgcmVsYXRpdmUgdG8gdGhlIG1hcCdzIGNlbnRlcixcbiAgICogICAgW3gsIHldIG1lYXN1cmVkIGluIHBpeGVscy5cbiAgICogQHJldHVybnMge1dlYk1lcmNhdG9yVmlld3BvcnR9XG4gICAqL1xuICBmaXRCb3VuZHMoYm91bmRzLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7d2lkdGgsIGhlaWdodH0gPSB0aGlzO1xuICAgIGNvbnN0IHtsb25naXR1ZGUsIGxhdGl0dWRlLCB6b29tfSA9IGZpdEJvdW5kcyhPYmplY3QuYXNzaWduKHt3aWR0aCwgaGVpZ2h0LCBib3VuZHN9LCBvcHRpb25zKSk7XG4gICAgcmV0dXJuIG5ldyBXZWJNZXJjYXRvclZpZXdwb3J0KHt3aWR0aCwgaGVpZ2h0LCBsb25naXR1ZGUsIGxhdGl0dWRlLCB6b29tfSk7XG4gIH1cblxuICAvLyBJTlRFUk5BTCBNRVRIT0RTXG5cbiAgX2dldFBhcmFtcygpIHtcbiAgICByZXR1cm4gdGhpcy5fZGlzdGFuY2VTY2FsZXM7XG4gIH1cbn1cblxuLyoqXG4gKiBQcm9qZWN0IFtsbmcsbGF0XSBvbiBzcGhlcmUgb250byBbeCx5XSBvbiA1MTIqNTEyIE1lcmNhdG9yIFpvb20gMCB0aWxlLlxuICogUGVyZm9ybXMgdGhlIG5vbmxpbmVhciBwYXJ0IG9mIHRoZSB3ZWIgbWVyY2F0b3IgcHJvamVjdGlvbi5cbiAqIFJlbWFpbmluZyBwcm9qZWN0aW9uIGlzIGRvbmUgd2l0aCA0eDQgbWF0cmljZXMgd2hpY2ggYWxzbyBoYW5kbGVzXG4gKiBwZXJzcGVjdGl2ZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBsbmdMYXQgLSBbbG5nLCBsYXRdIGNvb3JkaW5hdGVzXG4gKiAgIFNwZWNpZmllcyBhIHBvaW50IG9uIHRoZSBzcGhlcmUgdG8gcHJvamVjdCBvbnRvIHRoZSBtYXAuXG4gKiBAcmV0dXJuIHtBcnJheX0gW3gseV0gY29vcmRpbmF0ZXMuXG4gKi9cbmZ1bmN0aW9uIHByb2plY3RGbGF0KFtsbmcsIGxhdF0sIHNjYWxlKSB7XG4gIHNjYWxlID0gc2NhbGUgKiBXT1JMRF9TQ0FMRTtcbiAgY29uc3QgbGFtYmRhMiA9IGxuZyAqIERFR1JFRVNfVE9fUkFESUFOUztcbiAgY29uc3QgcGhpMiA9IGxhdCAqIERFR1JFRVNfVE9fUkFESUFOUztcbiAgY29uc3QgeCA9IHNjYWxlICogKGxhbWJkYTIgKyBQSSkgLyAoMiAqIFBJKTtcbiAgY29uc3QgeSA9IHNjYWxlICogKFBJIC0gTWF0aC5sb2coTWF0aC50YW4oUElfNCArIHBoaTIgKiAwLjUpKSkgLyAoMiAqIFBJKTtcbiAgcmV0dXJuIFt4LCB5XTtcbn1cblxuLyoqXG4gKiBVbnByb2plY3Qgd29ybGQgcG9pbnQgW3gseV0gb24gbWFwIG9udG8ge2xhdCwgbG9ufSBvbiBzcGhlcmVcbiAqXG4gKiBAcGFyYW0ge29iamVjdHxWZWN0b3J9IHh5IC0gb2JqZWN0IHdpdGgge3gseX0gbWVtYmVyc1xuICogIHJlcHJlc2VudGluZyBwb2ludCBvbiBwcm9qZWN0ZWQgbWFwIHBsYW5lXG4gKiBAcmV0dXJuIHtHZW9Db29yZGluYXRlc30gLSBvYmplY3Qgd2l0aCB7bGF0LGxvbn0gb2YgcG9pbnQgb24gc3BoZXJlLlxuICogICBIYXMgdG9BcnJheSBtZXRob2QgaWYgeW91IG5lZWQgYSBHZW9KU09OIEFycmF5LlxuICogICBQZXIgY2FydG9ncmFwaGljIHRyYWRpdGlvbiwgbGF0IGFuZCBsb24gYXJlIHNwZWNpZmllZCBhcyBkZWdyZWVzLlxuICovXG5mdW5jdGlvbiB1bnByb2plY3RGbGF0KFt4LCB5XSwgc2NhbGUpIHtcbiAgc2NhbGUgPSBzY2FsZSAqIFdPUkxEX1NDQUxFO1xuICBjb25zdCBsYW1iZGEyID0gKHggLyBzY2FsZSkgKiAoMiAqIFBJKSAtIFBJO1xuICBjb25zdCBwaGkyID0gMiAqIChNYXRoLmF0YW4oTWF0aC5leHAoUEkgLSAoeSAvIHNjYWxlKSAqICgyICogUEkpKSkgLSBQSV80KTtcbiAgcmV0dXJuIFtsYW1iZGEyICogUkFESUFOU19UT19ERUdSRUVTLCBwaGkyICogUkFESUFOU19UT19ERUdSRUVTXTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgZGlzdGFuY2Ugc2NhbGVzIGluIG1ldGVycyBhcm91bmQgY3VycmVudCBsYXQvbG9uLCBib3RoIGZvclxuICogZGVncmVlcyBhbmQgcGl4ZWxzLlxuICogSW4gbWVyY2F0b3IgcHJvamVjdGlvbiBtb2RlLCB0aGUgZGlzdGFuY2Ugc2NhbGVzIHZhcnkgc2lnbmlmaWNhbnRseVxuICogd2l0aCBsYXRpdHVkZS5cbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlRGlzdGFuY2VTY2FsZXMoe2xhdGl0dWRlLCBsb25naXR1ZGUsIHNjYWxlfSkge1xuICBhc3NlcnQoIWlzTmFOKGxhdGl0dWRlKSAmJiAhaXNOYU4obG9uZ2l0dWRlKSAmJiAhaXNOYU4oc2NhbGUpLCBFUlJfQVJHVU1FTlQpO1xuICAvLyBBcHByb3hpbWF0ZWx5IDExMWttIHBlciBkZWdyZWUgYXQgZXF1YXRvclxuICBjb25zdCBNRVRFUlNfUEVSX0RFR1JFRSA9IDExMTAwMDtcblxuICBjb25zdCBsYXRDb3NpbmUgPSBNYXRoLmNvcyhsYXRpdHVkZSAqIE1hdGguUEkgLyAxODApO1xuXG4gIGNvbnN0IG1ldGVyc1BlckRlZ3JlZSA9IE1FVEVSU19QRVJfREVHUkVFICogbGF0Q29zaW5lO1xuXG4gIC8vIENhbGN1bGF0ZSBudW1iZXIgb2YgcGl4ZWxzIG9jY3VwaWVkIGJ5IG9uZSBkZWdyZWUgbG9uZ2l0dWRlXG4gIC8vIGFyb3VuZCBjdXJyZW50IGxhdC9sb25cbiAgY29uc3QgcGl4ZWxzUGVyRGVncmVlWCA9IHZlYzIuZGlzdGFuY2UoXG4gICAgcHJvamVjdEZsYXQoW2xvbmdpdHVkZSArIDAuNSwgbGF0aXR1ZGVdLCBzY2FsZSksXG4gICAgcHJvamVjdEZsYXQoW2xvbmdpdHVkZSAtIDAuNSwgbGF0aXR1ZGVdLCBzY2FsZSlcbiAgKTtcbiAgLy8gQ2FsY3VsYXRlIG51bWJlciBvZiBwaXhlbHMgb2NjdXBpZWQgYnkgb25lIGRlZ3JlZSBsYXRpdHVkZVxuICAvLyBhcm91bmQgY3VycmVudCBsYXQvbG9uXG4gIGNvbnN0IHBpeGVsc1BlckRlZ3JlZVkgPSB2ZWMyLmRpc3RhbmNlKFxuICAgIHByb2plY3RGbGF0KFtsb25naXR1ZGUsIGxhdGl0dWRlICsgMC41XSwgc2NhbGUpLFxuICAgIHByb2plY3RGbGF0KFtsb25naXR1ZGUsIGxhdGl0dWRlIC0gMC41XSwgc2NhbGUpXG4gICk7XG5cbiAgY29uc3QgcGl4ZWxzUGVyTWV0ZXJYID0gcGl4ZWxzUGVyRGVncmVlWCAvIG1ldGVyc1BlckRlZ3JlZTtcbiAgY29uc3QgcGl4ZWxzUGVyTWV0ZXJZID0gcGl4ZWxzUGVyRGVncmVlWSAvIG1ldGVyc1BlckRlZ3JlZTtcbiAgY29uc3QgcGl4ZWxzUGVyTWV0ZXJaID0gKHBpeGVsc1Blck1ldGVyWCArIHBpeGVsc1Blck1ldGVyWSkgLyAyO1xuICAvLyBjb25zdCBwaXhlbHNQZXJNZXRlciA9IFtwaXhlbHNQZXJNZXRlclgsIHBpeGVsc1Blck1ldGVyWSwgcGl4ZWxzUGVyTWV0ZXJaXTtcblxuICBjb25zdCB3b3JsZFNpemUgPSBUSUxFX1NJWkUgKiBzY2FsZTtcbiAgY29uc3QgYWx0UGl4ZWxzUGVyTWV0ZXIgPSB3b3JsZFNpemUgLyAoNGU3ICogbGF0Q29zaW5lKTtcbiAgY29uc3QgcGl4ZWxzUGVyTWV0ZXIgPSBbYWx0UGl4ZWxzUGVyTWV0ZXIsIGFsdFBpeGVsc1Blck1ldGVyLCBhbHRQaXhlbHNQZXJNZXRlcl07XG4gIGNvbnN0IG1ldGVyc1BlclBpeGVsID0gWzEgLyBhbHRQaXhlbHNQZXJNZXRlciwgMSAvIGFsdFBpeGVsc1Blck1ldGVyLCAxIC8gcGl4ZWxzUGVyTWV0ZXJaXTtcblxuICBjb25zdCBwaXhlbHNQZXJEZWdyZWUgPSBbcGl4ZWxzUGVyRGVncmVlWCwgcGl4ZWxzUGVyRGVncmVlWSwgcGl4ZWxzUGVyTWV0ZXJaXTtcbiAgY29uc3QgZGVncmVlc1BlclBpeGVsID0gWzEgLyBwaXhlbHNQZXJEZWdyZWVYLCAxIC8gcGl4ZWxzUGVyRGVncmVlWSwgMSAvIHBpeGVsc1Blck1ldGVyWl07XG5cbiAgLy8gTWFpbiByZXN1bHRzLCB1c2VkIGZvciBjb252ZXJ0aW5nIG1ldGVycyB0byBsYXRsbmcgZGVsdGFzIGFuZCBzY2FsaW5nIG9mZnNldHNcbiAgcmV0dXJuIHtcbiAgICBwaXhlbHNQZXJNZXRlcixcbiAgICBtZXRlcnNQZXJQaXhlbCxcbiAgICBwaXhlbHNQZXJEZWdyZWUsXG4gICAgZGVncmVlc1BlclBpeGVsXG4gIH07XG59XG5cbi8vIEFUVFJJQlVUSU9OOlxuLy8gdmlldyBhbmQgcHJvamVjdGlvbiBtYXRyaXggY3JlYXRpb24gaXMgaW50ZW50aW9uYWxseSBrZXB0IGNvbXBhdGlibGUgd2l0aFxuLy8gbWFwYm94LWdsJ3MgaW1wbGVtZW50YXRpb24gdG8gZW5zdXJlIHRoYXQgc2VhbWxlc3MgaW50ZXJvcGVyYXRpb25cbi8vIHdpdGggbWFwYm94IGFuZCByZWFjdC1tYXAtZ2wuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL21hcGJveC9tYXBib3gtZ2wtanNcblxuLy8gVmFyaWFibGUgZm92IChpbiByYWRpYW5zKVxuZXhwb3J0IGZ1bmN0aW9uIGdldEZvdih7aGVpZ2h0LCBhbHRpdHVkZX0pIHtcbiAgcmV0dXJuIDIgKiBNYXRoLmF0YW4oKGhlaWdodCAvIDIpIC8gYWx0aXR1ZGUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2xpcHBpbmdQbGFuZXMoe2FsdGl0dWRlLCBwaXRjaH0pIHtcbiAgLy8gRmluZCB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgY2VudGVyIHBvaW50IHRvIHRoZSBjZW50ZXIgdG9wXG4gIC8vIGluIGFsdGl0dWRlIHVuaXRzIHVzaW5nIGxhdyBvZiBzaW5lcy5cbiAgY29uc3QgcGl0Y2hSYWRpYW5zID0gcGl0Y2ggKiBERUdSRUVTX1RPX1JBRElBTlM7XG4gIGNvbnN0IGhhbGZGb3YgPSBNYXRoLmF0YW4oMC41IC8gYWx0aXR1ZGUpO1xuICBjb25zdCB0b3BIYWxmU3VyZmFjZURpc3RhbmNlID1cbiAgICBNYXRoLnNpbihoYWxmRm92KSAqIGFsdGl0dWRlIC8gTWF0aC5zaW4oTWF0aC5QSSAvIDIgLSBwaXRjaFJhZGlhbnMgLSBoYWxmRm92KTtcblxuICAvLyBDYWxjdWxhdGUgeiB2YWx1ZSBvZiB0aGUgZmFydGhlc3QgZnJhZ21lbnQgdGhhdCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gIGNvbnN0IGZhclogPSBNYXRoLmNvcyhNYXRoLlBJIC8gMiAtIHBpdGNoUmFkaWFucykgKiB0b3BIYWxmU3VyZmFjZURpc3RhbmNlICsgYWx0aXR1ZGU7XG5cbiAgcmV0dXJuIHtmYXJaLCBuZWFyWjogMC4xfTtcbn1cblxuLy8gUFJPSkVDVElPTiBNQVRSSVg6IFBST0pFQ1RTIEZST00gQ0FNRVJBIChWSUVXKSBTUEFDRSBUTyBDTElQU1BBQ0VcbmV4cG9ydCBmdW5jdGlvbiBtYWtlUHJvamVjdGlvbk1hdHJpeEZyb21NZXJjYXRvclBhcmFtcyh7XG4gIHdpZHRoLFxuICBoZWlnaHQsXG4gIHBpdGNoLFxuICBhbHRpdHVkZSxcbiAgZmFyWk11bHRpcGxpZXIgPSAxMFxufSkge1xuICBjb25zdCB7bmVhclosIGZhclp9ID0gZ2V0Q2xpcHBpbmdQbGFuZXMoe2FsdGl0dWRlLCBwaXRjaH0pO1xuICBjb25zdCBmb3YgPSBnZXRGb3Yoe2hlaWdodCwgYWx0aXR1ZGV9KTtcblxuICBjb25zdCBwcm9qZWN0aW9uTWF0cml4ID0gbWF0NC5wZXJzcGVjdGl2ZShcbiAgICBjcmVhdGVNYXQ0KCksXG4gICAgZm92LCAgICAgICAgICAgICAgLy8gZm92IGluIHJhZGlhbnNcbiAgICB3aWR0aCAvIGhlaWdodCwgICAvLyBhc3BlY3QgcmF0aW9cbiAgICBuZWFyWiwgICAgICAgICAgICAvLyBuZWFyIHBsYW5lXG4gICAgZmFyWiAqIGZhclpNdWx0aXBsaWVyIC8vIGZhciBwbGFuZVxuICApO1xuXG4gIHJldHVybiBwcm9qZWN0aW9uTWF0cml4O1xufVxuXG5mdW5jdGlvbiBtYWtlVmlld01hdHJpeEZyb21NZXJjYXRvclBhcmFtcyh7XG4gIHdpZHRoLFxuICBoZWlnaHQsXG4gIGxvbmdpdHVkZSxcbiAgbGF0aXR1ZGUsXG4gIHpvb20sXG4gIHBpdGNoLFxuICBiZWFyaW5nLFxuICBhbHRpdHVkZSxcbiAgY2VudGVyXG59KSB7XG4gIC8vIFZJRVcgTUFUUklYOiBQUk9KRUNUUyBGUk9NIFZJUlRVQUwgUElYRUxTIFRPIENBTUVSQSBTUEFDRVxuICAvLyBOb3RlOiBBcyB1c3VhbCwgbWF0cml4IG9wZXJhdGlvbiBvcmRlcnMgc2hvdWxkIGJlIHJlYWQgaW4gcmV2ZXJzZVxuICAvLyBzaW5jZSB2ZWN0b3JzIHdpbGwgYmUgbXVsdGlwbGllZCBmcm9tIHRoZSByaWdodCBkdXJpbmcgdHJhbnNmb3JtYXRpb25cbiAgY29uc3Qgdm0gPSBjcmVhdGVNYXQ0KCk7XG5cbiAgLy8gTW92ZSBjYW1lcmEgdG8gYWx0aXR1ZGVcbiAgbWF0NC50cmFuc2xhdGUodm0sIHZtLCBbMCwgMCwgLWFsdGl0dWRlXSk7XG5cbiAgLy8gQWZ0ZXIgdGhlIHJvdGF0ZVgsIHogdmFsdWVzIGFyZSBpbiBwaXhlbCB1bml0cy4gQ29udmVydCB0aGVtIHRvXG4gIC8vIGFsdGl0dWRlIHVuaXRzLiAxIGFsdGl0dWRlIHVuaXQgPSB0aGUgc2NyZWVuIGhlaWdodC5cbiAgbWF0NC5zY2FsZSh2bSwgdm0sIFsxLCAtMSwgMSAvIGhlaWdodF0pO1xuXG4gIC8vIFJvdGF0ZSBieSBiZWFyaW5nLCBhbmQgdGhlbiBieSBwaXRjaCAod2hpY2ggdGlsdHMgdGhlIHZpZXcpXG4gIG1hdDQucm90YXRlWCh2bSwgdm0sIHBpdGNoICogREVHUkVFU19UT19SQURJQU5TKTtcbiAgbWF0NC5yb3RhdGVaKHZtLCB2bSwgLWJlYXJpbmcgKiBERUdSRUVTX1RPX1JBRElBTlMpO1xuICAvLyBjb25zb2xlLmxvZyhgVklFV1BUIFogJHtwaXRjaCAqIERFR1JFRVNfVE9fUkFESUFOU30gJHstYmVhcmluZyAqIERFR1JFRVNfVE9fUkFESUFOU30gJHt2bX1gKTtcbiAgbWF0NC50cmFuc2xhdGUodm0sIHZtLCBbLWNlbnRlclswXSwgLWNlbnRlclsxXSwgMF0pO1xuICAvLyBjb25zb2xlLmxvZyhgVklFV1BUIFQgJHtwaXRjaCAqIERFR1JFRVNfVE9fUkFESUFOU30gJHstYmVhcmluZyAqIERFR1JFRVNfVE9fUkFESUFOU30gJHt2bX1gKTtcbiAgcmV0dXJuIHZtO1xufVxuXG4vKipcbiAqIFJldHVybnMgbWFwIHNldHRpbmdzIHtsYXRpdHVkZSwgbG9uZ2l0dWRlLCB6b29tfVxuICogdGhhdCB3aWxsIGNvbnRhaW4gdGhlIHByb3ZpZGVkIGNvcm5lcnMgd2l0aGluIHRoZSBwcm92aWRlZCB3aWR0aC5cbiAqIE9ubHkgc3VwcG9ydHMgbm9uLXBlcnNwZWN0aXZlIG1vZGUuXG4gKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSB2aWV3cG9ydCB3aWR0aFxuICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIHZpZXdwb3J0IGhlaWdodFxuICogQHBhcmFtIHtBcnJheX0gYm91bmRzIC0gW1tsb24sIGxhdF0sIFtsb24sIGxhdF1dXG4gKiBAcGFyYW0ge051bWJlcn0gW3BhZGRpbmddIC0gVGhlIGFtb3VudCBvZiBwYWRkaW5nIGluIHBpeGVscyB0byBhZGQgdG8gdGhlIGdpdmVuIGJvdW5kcy5cbiAqIEBwYXJhbSB7QXJyYXl9IFtvZmZzZXRdIC0gVGhlIGNlbnRlciBvZiB0aGUgZ2l2ZW4gYm91bmRzIHJlbGF0aXZlIHRvIHRoZSBtYXAncyBjZW50ZXIsXG4gKiAgICBbeCwgeV0gbWVhc3VyZWQgaW4gcGl4ZWxzLlxuICogQHJldHVybnMge09iamVjdH0gLSBsYXRpdHVkZSwgbG9uZ2l0dWRlIGFuZCB6b29tXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaXRCb3VuZHMoe1xuICB3aWR0aCxcbiAgaGVpZ2h0LFxuICBib3VuZHMsXG4gIC8vIG9wdGlvbnNcbiAgcGFkZGluZyA9IDAsXG4gIG9mZnNldCA9IFswLCAwXVxufSkge1xuICBjb25zdCBbW3dlc3QsIHNvdXRoXSwgW2Vhc3QsIG5vcnRoXV0gPSBib3VuZHM7XG5cbiAgY29uc3Qgdmlld3BvcnQgPSBuZXcgV2ViTWVyY2F0b3JWaWV3cG9ydCh7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIGxvbmdpdHVkZTogMCxcbiAgICBsYXRpdHVkZTogMCxcbiAgICB6b29tOiAwXG4gIH0pO1xuXG4gIGNvbnN0IG53ID0gdmlld3BvcnQucHJvamVjdChbd2VzdCwgbm9ydGhdKTtcbiAgY29uc3Qgc2UgPSB2aWV3cG9ydC5wcm9qZWN0KFtlYXN0LCBzb3V0aF0pO1xuICBjb25zdCBzaXplID0gW1xuICAgIE1hdGguYWJzKHNlWzBdIC0gbndbMF0pLFxuICAgIE1hdGguYWJzKHNlWzFdIC0gbndbMV0pXG4gIF07XG4gIGNvbnN0IGNlbnRlciA9IFtcbiAgICAoc2VbMF0gKyBud1swXSkgLyAyLFxuICAgIChzZVsxXSArIG53WzFdKSAvIDJcbiAgXTtcblxuICBjb25zdCBzY2FsZVggPSAod2lkdGggLSBwYWRkaW5nICogMiAtIE1hdGguYWJzKG9mZnNldFswXSkgKiAyKSAvIHNpemVbMF07XG4gIGNvbnN0IHNjYWxlWSA9IChoZWlnaHQgLSBwYWRkaW5nICogMiAtIE1hdGguYWJzKG9mZnNldFsxXSkgKiAyKSAvIHNpemVbMV07XG5cbiAgY29uc3QgY2VudGVyTG5nTGF0ID0gdmlld3BvcnQudW5wcm9qZWN0KGNlbnRlcik7XG4gIGNvbnN0IHpvb20gPSB2aWV3cG9ydC56b29tICsgTWF0aC5sb2cyKE1hdGguYWJzKE1hdGgubWluKHNjYWxlWCwgc2NhbGVZKSkpO1xuXG4gIHJldHVybiB7XG4gICAgbG9uZ2l0dWRlOiBjZW50ZXJMbmdMYXRbMF0sXG4gICAgbGF0aXR1ZGU6IGNlbnRlckxuZ0xhdFsxXSxcbiAgICB6b29tXG4gIH07XG59XG4iXX0=